{"version":3,"file":"a-showcase.test.js","sources":["../node_modules/atomico/core.js","../src/hooks/use-event-move/use-event-move.js","../src/components/a-showcase/a-showcase.js","../src/components/a-showcase/a-showcase.test.js"],"sourcesContent":["const HOOK_MOUNT = Symbol(\"mount\");\r\nconst HOOK_MOUNTED = Symbol(\"mounted\");\r\nconst HOOK_UPDATE = Symbol(\"update\");\r\nconst HOOK_UPDATED = Symbol(\"updated\");\r\nconst HOOK_UNMOUNT = Symbol(\"unmount\");\r\nconst HOOK_CURRENT = {};\r\n\r\nfunction update(hook, type) {\r\n    hook[0] && (hook[1] = hook[0](hook[1], type));\r\n}\r\n\r\nfunction updateAll(hooks, type) {\r\n    for (let i in hooks) update(hooks[i], type);\r\n}\r\n\r\nfunction useHook(reducer, initialState) {\r\n    if (HOOK_CURRENT.ref.hook) {\r\n        return HOOK_CURRENT.ref.hook.use(reducer, initialState)[1];\r\n    }\r\n}\r\n\r\nfunction useRender() {\r\n    return HOOK_CURRENT.ref.render;\r\n}\r\n\r\nfunction createHooks(render, host) {\r\n    let hooks = {};\r\n    let mounted;\r\n    let hook = {\r\n        use,\r\n        load,\r\n        updated,\r\n        unmount\r\n    };\r\n\r\n    let ref = { hook, host, render };\r\n\r\n    function load(callback, param) {\r\n        HOOK_CURRENT.index = 0;\r\n        HOOK_CURRENT.ref = ref;\r\n        let resolve = callback(param);\r\n        HOOK_CURRENT.ref = 0;\r\n        return resolve;\r\n    }\r\n    function use(reducer, state) {\r\n        let index = HOOK_CURRENT.index++;\r\n        let mount;\r\n        // record the hook and the initial state of this\r\n        if (!hooks[index]) {\r\n            hooks[index] = [null, state];\r\n            mount = 1;\r\n        }\r\n        // The hook always receives the last reduce.\r\n        hooks[index][0] = reducer;\r\n        update(hooks[index], mount ? HOOK_MOUNT : HOOK_UPDATE);\r\n        return hooks[index];\r\n    }\r\n    function updated() {\r\n        let type = mounted ? HOOK_UPDATED : HOOK_MOUNTED;\r\n        mounted = 1;\r\n        updateAll(hooks, type);\r\n    }\r\n    function unmount() {\r\n        updateAll(hooks, HOOK_UNMOUNT);\r\n    }\r\n    return hook;\r\n}\n\nconst ARRAY_EMPTY = [];\r\n\r\nconst NODE_HOST = \"host\";\r\n\r\nconst LIMIT_NODE = Symbol(\"limitNode\");\r\n\r\nconst IGNORE_CHILDREN = {\r\n    innerHTML: 1,\r\n    textContent: 1,\r\n    contenteditable: 1\r\n};\r\n\r\nconst JOIN_CHILDREN = {\r\n    style: 1\r\n};\r\n\r\nconst HYDRATE_PROPS = {\r\n    id: 1,\r\n    className: 1,\r\n    checked: 1,\r\n    value: 1,\r\n    selected: 1\r\n};\n\n/**\r\n * Return if value is array\r\n * @param {*}\r\n * @return {boolean}\r\n */\r\nconst isArray = value => Array.isArray(value);\r\n/**\r\n * compare 2 array\r\n * @param {array} before\r\n * @param {array} after\r\n * @example\r\n * isEqualArray([1,2,3,4],[1,2,3,4]) // true\r\n * isEqualArray([1,2,3,4],[1,2,3])   // false\r\n * isEqualArray([5,1,2,3],[1,2,3,5]) // false\r\n * isEqualArray([],[]) // true\r\n * @returns {boolean}\r\n */\r\nfunction isEqualArray(before, after) {\r\n    let length = before.length;\r\n    if (length !== after.length) return false;\r\n    for (let i = 0; i < length; i++) {\r\n        if (before[i] !== after[i]) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nconst isFunction = value => typeof value == \"function\";\r\n\r\n// export function fps(callback, count = 3) {\r\n//     count-- ? requestAnimationFrame(() => fps(callback, count)) : callback();\r\n// }\r\n\r\nconst promise = callback => new Promise(callback);\n\n/**\r\n *\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {Object} props\r\n * @param {Object} nextProps\r\n * @param {boolean} isSvg\r\n * @param {Object} handlers\r\n **/\r\nfunction diffProps(node, props, nextProps, isSvg, handlers) {\r\n    props = props || {};\r\n\r\n    for (let key in props) {\r\n        if (!(key in nextProps)) {\r\n            setProperty(node, key, props[key], null, isSvg, handlers);\r\n        }\r\n    }\r\n    let ignoreChildren;\r\n    for (let key in nextProps) {\r\n        setProperty(node, key, props[key], nextProps[key], isSvg, handlers);\r\n        ignoreChildren = ignoreChildren || IGNORE_CHILDREN[key];\r\n    }\r\n    return ignoreChildren;\r\n}\r\n\r\nfunction setProperty(node, key, prevValue, nextValue, isSvg, handlers) {\r\n    key = key == \"class\" && !isSvg ? \"className\" : key;\r\n    // define empty value\r\n    prevValue = prevValue == null ? null : prevValue;\r\n    nextValue = nextValue == null ? null : nextValue;\r\n\r\n    if (key in node && HYDRATE_PROPS[key]) {\r\n        prevValue = node[key];\r\n    }\r\n\r\n    if (nextValue === prevValue) return;\r\n\r\n    if (\r\n        key[0] == \"o\" &&\r\n        key[1] == \"n\" &&\r\n        (isFunction(nextValue) || isFunction(prevValue))\r\n    ) {\r\n        setEvent(node, key, nextValue, handlers);\r\n        return;\r\n    }\r\n\r\n    switch (key) {\r\n        case \"key\":\r\n            node.dataset.key = nextValue;\r\n            break;\r\n        case \"ref\":\r\n            if (nextValue) nextValue.current = node;\r\n            break;\r\n        case \"style\":\r\n            setStyle(node, prevValue || \"\", nextValue || \"\");\r\n            break;\r\n        default:\r\n            if (!isSvg && key != \"list\" && key in node) {\r\n                node[key] = nextValue == null ? \"\" : nextValue;\r\n            } else if (nextValue == null) {\r\n                node.removeAttribute(key);\r\n            } else {\r\n                node.setAttribute(\r\n                    key,\r\n                    typeof nextValue == \"object\"\r\n                        ? JSON.stringify(nextValue)\r\n                        : nextValue\r\n                );\r\n            }\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {string} type\r\n * @param {function} [nextHandler]\r\n * @param {object} handlers\r\n */\r\nfunction setEvent(node, type, nextHandler, handlers) {\r\n    // get the name of the event to use\r\n    type = type.slice(type[2] == \"-\" ? 3 : 2);\r\n    // add handleEvent to handlers\r\n    if (!handlers.handleEvent) {\r\n        /**\r\n         * {@link https://developer.mozilla.org/es/docs/Web/API/EventTarget/addEventListener#The_value_of_this_within_the_handler}\r\n         **/\r\n        handlers.handleEvent = event => handlers[event.type].call(node, event);\r\n    }\r\n    if (nextHandler) {\r\n        // create the subscriber if it does not exist\r\n        if (!handlers[type]) {\r\n            node.addEventListener(type, handlers);\r\n        }\r\n        // update the associated event\r\n        handlers[type] = nextHandler;\r\n    } else {\r\n        // \tdelete the associated event\r\n        if (handlers[type]) {\r\n            node.removeEventListener(type, handlers);\r\n            delete handlers[type];\r\n        }\r\n    }\r\n}\r\n/**\r\n * define style as string inline,this generates less mutation\r\n * to the sun and cleans the previously defined properties.\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {(string|object)} prevValue\r\n * @param {(string|object)} nextValue\r\n */\r\nfunction setStyle(node, prevValue, nextValue) {\r\n    let style = node.style,\r\n        prevIsObject;\r\n    if (typeof prevValue == \"object\") {\r\n        prevIsObject = true;\r\n        for (let key in prevValue) {\r\n            if (!(key in nextValue)) setPropertyStyle(style, key, null);\r\n        }\r\n    }\r\n    if (typeof nextValue == \"object\") {\r\n        for (let key in nextValue) {\r\n            let value = nextValue[key];\r\n            if (prevIsObject && prevValue[key] === value) continue;\r\n            setPropertyStyle(style, key, value);\r\n        }\r\n    } else {\r\n        style.cssText = nextValue;\r\n    }\r\n}\r\n\r\nfunction setPropertyStyle(style, key, value) {\r\n    let method = \"setProperty\";\r\n    if (value == null) {\r\n        method = \"removeProperty\";\r\n        value = null;\r\n    }\r\n    if (~key.indexOf(\"-\")) {\r\n        style[method](key, value);\r\n    } else {\r\n        style[key] = value;\r\n    }\r\n}\n\nlet vNodeEmpty = createElement(null, { children: \"\" });\r\n\r\nlet vNodeFill = createElement(null, { children: ARRAY_EMPTY });\r\n\r\nconst META_MAP_CHILDREN = Symbol(\"mapChildren\");\r\n\r\nconst META_KEYES = Symbol(\"keyes\");\r\n/**\r\n * @param {VnodeType} nodeType\r\n * @param {VnodeProps} [props]\r\n * @param {Vnode|Vnode[]} [children]\r\n * @returns {Vnode}\r\n **/\r\nfunction createElement(nodeType, props, ...children) {\r\n    return { children, ...props, nodeType: nodeType || null };\r\n}\r\n/**\r\n * toVnode, processes the object for correct use within the diff process.\r\n **/\r\nfunction toVnode(value) {\r\n    if (isVnodeValue(value)) {\r\n        return value;\r\n    } else {\r\n        // this process occurs only once per vnode\r\n        if (!value[META_MAP_CHILDREN]) {\r\n            let { children, keyes } = mapChildren(value.children);\r\n            value.children = children.length ? children : ARRAY_EMPTY;\r\n            if (keyes && keyes.length == children.length) {\r\n                value[META_KEYES] = keyes;\r\n            }\r\n            value[META_MAP_CHILDREN] = true;\r\n        }\r\n    }\r\n    return value;\r\n}\r\n\r\nfunction mapChildren(children, scan = { children: [] }, deep = 0) {\r\n    if (isArray(children)) {\r\n        let length = children.length;\r\n        for (let i = 0; i < length; i++) {\r\n            mapChildren(children[i], scan, deep + 1);\r\n        }\r\n    } else {\r\n        if (children == null && !deep) return scan;\r\n\r\n        let vnode = toVnode(children);\r\n\r\n        if (vnode != null && typeof vnode == \"object\") {\r\n            if (isFunction(vnode.nodeType)) {\r\n                let { nodeType, ...props } = vnode;\r\n                return mapChildren(nodeType(props), scan, deep + 1);\r\n            }\r\n            let { key } = vnode;\r\n            if (key != null) {\r\n                key += \"\";\r\n                scan.keyes = scan.keyes || [];\r\n                if (!scan.keyes.includes(key)) {\r\n                    scan.keyes.push(key);\r\n                }\r\n            }\r\n        }\r\n\r\n        scan.children.push(vnode);\r\n    }\r\n    return scan;\r\n}\r\n\r\nfunction isVnodeEmpty(value) {\r\n    let type = typeof value;\r\n    return value == null || type == \"boolean\" || type == \"function\";\r\n}\r\n\r\nfunction fillVnodeValue(value) {\r\n    return isVnodeEmpty(value)\r\n        ? vNodeEmpty\r\n        : createElement(null, { children: \"\" + value });\r\n}\r\n\r\nfunction isVnodeValue(value) {\r\n    let type = typeof value;\r\n    return (\r\n        value == null ||\r\n        type == \"string\" ||\r\n        type == \"number\" ||\r\n        type == \"function\" ||\r\n        type == \"boolean\"\r\n    );\r\n}\r\n\r\n/**\r\n * @typedef {(Object<string,any>)} VnodeProps;\r\n *\r\n * @typedef {(Function|string)} VnodeType;\r\n *\r\n * @typedef {{type:VnodeType,props:VnodeProps}} Vnode\r\n **/\n\nconst isRawNode = node => node instanceof Node;\r\n\r\nconst createLimitNode = parent =>\r\n    (parent[LIMIT_NODE] = parent.appendChild(new Comment()));\r\n/**\r\n *\r\n * @param {string} type\r\n * @param {boolean} isSvg\r\n * @returns {import(\"./render\").HTMLNode}\r\n */\r\nfunction createNode(type, isSvg, is) {\r\n    let doc = document;\r\n    let nextNode;\r\n    if (type != null) {\r\n        if (isRawNode(type)) {\r\n            return type;\r\n        }\r\n        nextNode = isSvg\r\n            ? doc.createElementNS(\"http://www.w3.org/2000/svg\", type)\r\n            : doc.createElement(type, is ? { is } : null);\r\n    } else {\r\n        nextNode = doc.createTextNode(\"\");\r\n    }\r\n    return nextNode;\r\n}\r\n/**\r\n * compare 2 nodes, to define if these are equal\r\n * @param {string|null|HTMLElement|SVGElement} nodeA\r\n * @param {string|null|HTMLElement|SVGElement} nodeB\r\n */\r\nfunction equalNode(nodeA, nodeB) {\r\n    let isRawA = nodeA && isRawNode(nodeA);\r\n    let isRawB = nodeB && isRawNode(nodeB);\r\n    if (isRawB && isRawA) {\r\n        return isRawB == isRawB;\r\n    }\r\n    if (nodeA) {\r\n        if (!nodeA.localName) {\r\n            nodeA.localName = nodeA.nodeName.toLowerCase();\r\n        }\r\n\r\n        let localName = nodeA.localName;\r\n        return (localName == \"#text\" ? null : localName) == nodeB;\r\n    }\r\n}\r\n\r\nfunction insertNode(parent, newNode, beforeNode, afterLimit) {\r\n    let limitNode = parent[LIMIT_NODE];\r\n\r\n    if (!limitNode) {\r\n        let { childNodes } = parent;\r\n        let length = childNodes.length;\r\n        for (let i = 0; i < length; i++) {\r\n            let child = childNodes[length];\r\n            if (child instanceof Comment) {\r\n                limitNode = child;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!limitNode) limitNode = createLimitNode(parent);\r\n\r\n    parent[afterLimit ? \"appendChild\" : \"insertBefore\"](\r\n        newNode,\r\n        beforeNode || limitNode\r\n    );\r\n}\n\n/**\r\n *\r\n * @param {import(\"./render\").ConfigRender} config\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {import(\"./vnode\").Vnode} nextVnode\r\n * @param {boolean} isSvg\r\n * @param {Function} currentUpdateComponent\r\n * @return {import(\"./render\").HTMLNode}\r\n **/\r\nfunction diff(id, node, nextVnode, isSvg) {\r\n    let { vnode, handlers = {} } = (node && node[id]) || {};\r\n\r\n    if (vnode == nextVnode && vnode != null) return node;\r\n\r\n    nextVnode = isVnodeValue(nextVnode) ? fillVnodeValue(nextVnode) : nextVnode;\r\n\r\n    let { nodeType, shadowDom, children, is, ...props } = vnode || vNodeFill;\r\n\r\n    let {\r\n        nodeType: nextNodeType,\r\n        shadowDom: nextShadowDom,\r\n        children: nextChildren,\r\n        is: nextIs,\r\n        ...nextProps\r\n    } = nextVnode;\r\n\r\n    isSvg = isSvg || nextNodeType == \"svg\";\r\n\r\n    if (\r\n        nextNodeType != NODE_HOST &&\r\n        (!equalNode(node, nextNodeType) || is != nextIs)\r\n    ) {\r\n        let nextNode = createNode(nextNodeType, isSvg, nextIs);\r\n        let parent = node && node.parentNode;\r\n        if (parent) {\r\n            parent.replaceChild(nextNode, node);\r\n        }\r\n\r\n        node = nextNode;\r\n        handlers = {};\r\n    }\r\n\r\n    if (JOIN_CHILDREN[nextNodeType]) {\r\n        nextNodeType = null;\r\n        nextChildren = nextChildren.join(\"\");\r\n    }\r\n    if (nextNodeType == null) {\r\n        if (node.textContent != nextChildren) {\r\n            node.textContent = nextChildren;\r\n        }\r\n    } else {\r\n        if (shadowDom != nextShadowDom) {\r\n            let { shadowRoot } = node;\r\n            let mode =\r\n                nextShadowDom && !shadowRoot\r\n                    ? \"open\"\r\n                    : !nextShadowDom && shadowRoot\r\n                    ? \"closed\"\r\n                    : 0;\r\n            if (mode) node.attachShadow({ mode });\r\n        }\r\n\r\n        let ignoreChildren = diffProps(\r\n            node,\r\n            props,\r\n            nextProps,\r\n            isSvg,\r\n            handlers);\r\n\r\n        if (!ignoreChildren && children != nextChildren) {\r\n            diffChildren(\r\n                id,\r\n                nextShadowDom ? node.shadowRoot : node,\r\n                nextChildren,\r\n                nextProps[META_KEYES],\r\n                isSvg\r\n            );\r\n        }\r\n    }\r\n    node[id] = { vnode: nextVnode, handlers };\r\n    return node;\r\n}\r\n/**\r\n *\r\n * @param {import(\"./render\").ConfigRender} config\r\n * @param {import(\"./render\").HTMLNode} parent\r\n * @param {import(\"./vnode\").Vnode[]} [nextChildren]\r\n * @param {boolean} isSvg\r\n */\r\nfunction diffChildren(id, parent, children, keyes, isSvg) {\r\n    let childrenLenght = children.length;\r\n    let { childNodes } = parent;\r\n    let childNodesKeyes = {};\r\n    let childNodesLength = childNodes.length;\r\n    let index = 0;\r\n    // limit Atomico's reach only to the comment marker\r\n    let limitNode = parent[LIMIT_NODE];\r\n\r\n    for (; index < childNodesLength; index++) {\r\n        let childNode = childNodes[index];\r\n        if (childNode == limitNode || childNode instanceof Comment) {\r\n            limitNode = childNode;\r\n            break;\r\n        }\r\n        if (keyes) {\r\n            let key = childNode.dataset.key;\r\n            if (keyes.includes(key)) {\r\n                childNodesKeyes[key] = childNode;\r\n                continue;\r\n            }\r\n        }\r\n\r\n        if (keyes || index >= childrenLenght) {\r\n            index--;\r\n            childNodesLength--;\r\n            childNode.remove();\r\n        }\r\n    }\r\n    // If you don't find a bookmark in the list, you create it.\r\n    if (!limitNode) limitNode = createLimitNode(parent);\r\n\r\n    for (let i = 0; i < childrenLenght; i++) {\r\n        let child = children[i];\r\n        let indexChildNode = i == index ? null : childNodes[i];\r\n        let key = keyes ? child.key : i;\r\n        let childNode = keyes ? childNodesKeyes[key] : indexChildNode;\r\n\r\n        if (keyes && childNode) {\r\n            if (childNode != indexChildNode) {\r\n                parent.insertBefore(childNode, indexChildNode);\r\n            }\r\n        }\r\n\r\n        let nextChildNode = diff(id, childNode, child, isSvg);\r\n\r\n        if (!childNode) {\r\n            insertNode(\r\n                parent,\r\n                nextChildNode,\r\n                i == index ? limitNode : childNodes[i]\r\n            );\r\n            // increase the limit position since a new node has been inserted\r\n            index++;\r\n        }\r\n    }\r\n}\n\nfunction render(vnode, node, id = \"vnode\") {\r\n    if (\r\n        vnode != null &&\r\n        typeof vnode == \"object\" &&\r\n        vnode.nodeType != NODE_HOST\r\n    ) {\r\n        vnode = createElement(NODE_HOST, { children: vnode });\r\n    }\r\n    vnode = toVnode(vnode);\r\n    diff(id, node, vnode);\r\n    return node;\r\n}\n\nconst TRUE_VALUES = [true, 1, \"\", \"1\", \"true\"];\r\n\r\nfunction formatType(value, type = String) {\r\n    try {\r\n        if (type == Boolean) {\r\n            value = TRUE_VALUES.includes(value);\r\n        } else if (typeof value == \"string\") {\r\n            value =\r\n                type == Number\r\n                    ? Number(value)\r\n                    : type == Object || type == Array\r\n                    ? JSON.parse(value)\r\n                    : value;\r\n        }\r\n        if ({}.toString.call(value) == `[object ${type.name}]`) {\r\n            return { value, error: type == Number && Number.isNaN(value) };\r\n        }\r\n    } catch (e) {}\r\n\r\n    return { value, error: true };\r\n}\r\n\r\nconst setAttr = (node, attr, value) =>\r\n    value == null\r\n        ? node.removeAttribute(attr)\r\n        : node.setAttribute(\r\n              attr,\r\n              typeof value == \"object\" ? JSON.stringify(value) : value\r\n          );\r\n\r\nconst propToAttr = prop => prop.replace(/([A-Z])/g, \"-$1\").toLowerCase();\r\n\r\nconst attrToProp = attr =>\r\n    attr.replace(/-(\\w)/g, (all, letter) => letter.toUpperCase());\r\n\r\nconst dispatchEvent = (node, type, customEventInit) =>\r\n    node.dispatchEvent(\r\n        new CustomEvent(\r\n            type,\r\n            typeof customEventInit == \"object\" ? customEventInit : null\r\n        )\r\n    );\r\n\r\nconst createPropError = (status, message) =>\r\n    Object.assign(new Error(\"Failed prop\\n\" + message), status);\n\nconst defer = callback => Promise.resolve().then(callback);\r\nconst maxFps = 1000 / 60;\r\n\r\nlet queue = [];\r\nlet running;\r\n\r\nconst IMPORTANT = Symbol(\"important\");\r\n\r\nfunction clearQueue() {\r\n    let time = performance.now();\r\n\r\n    let length = queue.length;\r\n    let current = queue;\r\n\r\n    queue = [];\r\n\r\n    while (length--) {\r\n        let callback = current[length];\r\n        // if in case one is defined as important, the execution will be forced\r\n        if (callback[IMPORTANT] || performance.now() - time < maxFps) {\r\n            callback();\r\n        } else {\r\n            queue = queue.concat(current.slice(0, length + 1));\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (queue.length) {\r\n        requestAnimationFrame(clearQueue);\r\n        return;\r\n    }\r\n    running = false;\r\n}\r\n/**\r\n * add a task to the queue\r\n * @param {Function} callback\r\n * @returns {Promise} Generate a promise that show  if the queue is complete\r\n */\r\nfunction addQueue(callback) {\r\n    if (!running) {\r\n        running = true;\r\n        defer(clearQueue);\r\n    }\r\n    // if the callback is defined as IMPORTANT,\r\n    // it is assumed to be in favor of the tree\r\n    // of the DOM  that must be added by unshift,\r\n    // assuming that the mount will be carried\r\n    // out in order, the shift priority only works\r\n    // after the first render\r\n    if (!queue.includes(callback))\r\n        queue[callback[IMPORTANT] ? \"unshift\" : \"push\"](callback);\r\n}\n\nconst ELEMENT_PROPS = Symbol(\"props\");\r\nconst ELEMENT_IGNORE_ATTR = Symbol(\"ignore\");\r\n\r\nfunction load(target, componentRender, componentError) {\r\n    if (target.mount) return;\r\n\r\n    let id = Symbol(\"vnode\");\r\n\r\n    let isPrevent;\r\n    let isUnmount;\r\n\r\n    target[ELEMENT_PROPS] = {};\r\n\r\n    let isMounted;\r\n\r\n    let resolveUpdate;\r\n\r\n    let rerender = () => {\r\n        // disables blocking, allowing the cycle to be regenerate\r\n        isPrevent = false;\r\n        // After the first render it disables the important condition\r\n        if (rerender[IMPORTANT]) rerender[IMPORTANT] = false;\r\n        try {\r\n            render(\r\n                hooks.load(componentRender, { ...target[ELEMENT_PROPS] }),\r\n                target,\r\n                id\r\n            );\r\n\r\n            resolveUpdate();\r\n        } catch (e) {\r\n            (componentError || console.error)(e);\r\n        }\r\n    };\r\n    // mark the first render as important, target speeds up the rendering\r\n    rerender[IMPORTANT] = true;\r\n\r\n    target.update = () => {\r\n        if (isUnmount) return;\r\n        let rendered = target.rendered;\r\n        if (!isPrevent) {\r\n            isPrevent = true;\r\n            // create a promise to observe the status of the update\r\n            rendered = promise(resolve => (resolveUpdate = resolve)).then(\r\n                // the UPDATED state is only propagated through\r\n                // the resolution of the promise\r\n                // Why? ... to improve communication between web-component parent and children\r\n                hooks.updated\r\n            );\r\n\r\n            // if the component is already mounted, avoid using target.mounted,\r\n            // to speed up the microtask\r\n            isMounted\r\n                ? addQueue(rerender)\r\n                : target.mounted.then(() => {\r\n                      isMounted = true;\r\n                      addQueue(rerender);\r\n                  });\r\n        }\r\n\r\n        return (target.rendered = rendered);\r\n    };\r\n\r\n    // any update from hook is added to a separate queue\r\n    let hooks = createHooks(() => addQueue(target.update), target);\r\n\r\n    // creates a collection of microtask\r\n    // associated with the mounted of the component\r\n\r\n    target.mounted = promise(\r\n        resolve =>\r\n            (target.mount = () => {\r\n                isMounted = false;\r\n                // allows the reuse of the component when it is isUnmounted and mounted\r\n                if (isUnmount == true) {\r\n                    isUnmount = false;\r\n                    target.mounted = target.update();\r\n                }\r\n                resolve();\r\n            })\r\n    );\r\n    /**\r\n     * creates a collection of microtask\r\n     * associated with the unmounted of the component\r\n     */\r\n    target.unmounted = promise(\r\n        resolve =>\r\n            (target.unmount = () => {\r\n                isUnmount = true;\r\n                hooks.unmount();\r\n                resolve();\r\n            })\r\n    );\r\n\r\n    target.initialize();\r\n\r\n    target.update();\r\n}\r\n\r\n/**\r\n * register the component, be it a class or function\r\n * @param {string} nodeType\r\n * @param {Function} component\r\n * @return {Function} returns a jsx component\r\n */\r\nfunction customElement(nodeType, component, options) {\r\n    if (isFunction(nodeType)) {\r\n        // By defining nodeType as a function, custom ELement\r\n        // allows the assignment of a constructor to be extended\r\n        let BaseElement = component || HTMLElement;\r\n\r\n        component = nodeType;\r\n\r\n        let { props, error } = component;\r\n\r\n        /**@type {Function[]}*/\r\n        let initialize = [];\r\n\r\n        /**@type {string[]} */\r\n        let attrs = [];\r\n\r\n        let CustomElement = class extends BaseElement {\r\n            constructor() {\r\n                super();\r\n                /**\r\n                 * identifier to store the virtual-dom state,\r\n                 * this is unique between instances of the\r\n                 * component to securely consider the host status\r\n                 */\r\n                load(this, component, error);\r\n            }\r\n            connectedCallback() {\r\n                load(this, component, error);\r\n                this.mount();\r\n            }\r\n            disconnectedCallback() {\r\n                this.unmount();\r\n            }\r\n            attributeChangedCallback(attr, oldValue, value) {\r\n                if (attr === this[ELEMENT_IGNORE_ATTR] || oldValue === value)\r\n                    return;\r\n                this[attrToProp(attr)] = value;\r\n            }\r\n            initialize() {\r\n                let length = initialize.length;\r\n                while (length--) initialize[length](this);\r\n            }\r\n        };\r\n\r\n        let prototype = CustomElement.prototype;\r\n\r\n        for (let prop in props)\r\n            setProperty$1(prototype, initialize, attrs, prop, props[prop]);\r\n\r\n        CustomElement.observedAttributes = attrs;\r\n\r\n        CustomElement.props = props;\r\n\r\n        return CustomElement;\r\n    } else {\r\n        let { base, ...opts } = options || {};\r\n        let define = () =>\r\n            customElements.define(\r\n                nodeType,\r\n                customElement(component, base),\r\n                opts\r\n            );\r\n        // it allows to wait for one or more webcomponents\r\n        // to be defined before the definition of this\r\n        opts.waitFor\r\n            ? Promise.all(\r\n                  []\r\n                      .concat(opts.waitFor)\r\n                      .map(nodeType => customElements.whenDefined(nodeType))\r\n              ).then(define)\r\n            : define();\r\n        return props =>\r\n            opts.extends\r\n                ? createElement(opts.extends, { ...props, is: nodeType })\r\n                : createElement(nodeType, props);\r\n    }\r\n}\r\n\r\nfunction setProperty$1(prototype, initialize, attrs, prop, schema) {\r\n    // avoid rewriting the prototype\r\n    if (prop in prototype) return;\r\n\r\n    let attr = propToAttr(prop);\r\n\r\n    schema = schema.name ? { type: schema } : schema;\r\n\r\n    let isTypeFunction = schema.type == Function;\r\n\r\n    function set(nextValue) {\r\n        let prevValue = this[ELEMENT_PROPS][prop];\r\n        // if the next value in function, with the exception of the type function,\r\n        // will be executed to get the next value\r\n        if (!isTypeFunction && isFunction(nextValue)) {\r\n            nextValue = nextValue(prevValue);\r\n        }\r\n        // Evaluate the defined type, to work with the value or issue an error\r\n        let { value, error } = formatType(nextValue, schema.type);\r\n\r\n        // define if the definition of prop has generated a type error\r\n        if (error && value != null) {\r\n            throw createPropError(\r\n                {\r\n                    target: this,\r\n                    schema,\r\n                    value\r\n                },\r\n                `The value defined for prop '${prop}' must be of type '${schema.type.name}'`\r\n            );\r\n        }\r\n        // define if the prop definition has generated an options error\r\n        if (schema.options && !schema.options.includes(value)) {\r\n            throw createPropError(\r\n                {\r\n                    target: this,\r\n                    schema,\r\n                    value\r\n                },\r\n                `The value defined for prop '${prop}' It is not a valid option`\r\n            );\r\n        }\r\n\r\n        if (prevValue == value) return;\r\n\r\n        this[ELEMENT_PROPS][prop] = value;\r\n\r\n        let rendered = this.update();\r\n\r\n        if (schema.event) {\r\n            // The event is only dispatched if the component has finished\r\n            // the rendering cycle, this is useful to observe the changes\r\n            rendered.then(() =>\r\n                dispatchEvent(this, schema.event.type || prop, schema.event)\r\n            );\r\n        }\r\n\r\n        if (schema.reflect) {\r\n            // the default properties are only reflected once the web-component is mounted\r\n            this.mounted.then(() => {\r\n                this[ELEMENT_IGNORE_ATTR] = attr; //update is prevented\r\n                setAttr(\r\n                    this,\r\n                    attr,\r\n                    schema.type == Boolean && !value ? null : value //\r\n                );\r\n                this[ELEMENT_IGNORE_ATTR] = false; // an upcoming update is allowed\r\n            });\r\n        }\r\n    }\r\n\r\n    function get() {\r\n        return this[ELEMENT_PROPS][prop];\r\n    }\r\n\r\n    Object.defineProperty(prototype, prop, { set, get });\r\n\r\n    if (\"value\" in schema) {\r\n        initialize.push(target => {\r\n            let { value } = schema;\r\n            target[prop] = isFunction(value) ? value() : value;\r\n        });\r\n    }\r\n    attrs.push(attr);\r\n}\n\nfunction useHost() {\r\n    return useHook(0, { current: HOOK_CURRENT.ref.host });\r\n}\r\n\r\nfunction useState(initialState) {\r\n    let render = useRender();\r\n    return useHook((state, type) => {\r\n        if (HOOK_MOUNT == type) {\r\n            state[0] = isFunction(initialState) ? initialState() : initialState;\r\n            state[1] = nextState => {\r\n                nextState = isFunction(nextState)\r\n                    ? nextState(state[0])\r\n                    : nextState;\r\n                if (nextState != state[0]) {\r\n                    state[0] = nextState;\r\n                    render();\r\n                }\r\n            };\r\n        }\r\n        return state;\r\n    }, []);\r\n}\r\n\r\nfunction useEffect(callback, args) {\r\n    // define whether the effect in the render cycle should be regenerated\r\n    let executeEffect;\r\n    useHook((state, type) => {\r\n        if (executeEffect == null) {\r\n            executeEffect =\r\n                args && state[0] ? !isEqualArray(args, state[0]) : true;\r\n            state[0] = args;\r\n        }\r\n\r\n        switch (type) {\r\n            case HOOK_UPDATE:\r\n            case HOOK_UNMOUNT:\r\n                // save the current args, for comparison\r\n                if ((executeEffect || type == HOOK_UNMOUNT) && state[1]) {\r\n                    // compare the previous snapshot with the generated state\r\n                    state[1]();\r\n                    // clean the effect collector\r\n                    state[1] = 0;\r\n                }\r\n                // delete the previous argument for a hook\r\n                // run if the hook is inserted in a new node\r\n                // Why? ... to perform again dom operations associated with the parent\r\n                if (type == HOOK_UNMOUNT) {\r\n                    state[0] = null;\r\n                }\r\n                break;\r\n            case HOOK_MOUNTED:\r\n            case HOOK_UPDATED:\r\n                // save the current args, for comparison, repeats due to additional type HOOK_MOUNTED\r\n                if (executeEffect || type == HOOK_MOUNTED) {\r\n                    // save the effect collector\r\n                    state[1] = callback();\r\n                }\r\n                // save the comparison argument\r\n                break;\r\n        }\r\n        return state;\r\n    }, []);\r\n}\r\n\r\nfunction useRef(current) {\r\n    return useHook(0, { current });\r\n}\r\n\r\nfunction useMemo(callback, args) {\r\n    let state = useHook(0, []);\r\n\r\n    if (!state[0] || (state[0] && (!args || !isEqualArray(state[0], args)))) {\r\n        state[1] = callback();\r\n    }\r\n    state[0] = args;\r\n    return state[1];\r\n}\r\n\r\nfunction useReducer(reducer, initialState) {\r\n    let render = useRender();\r\n    let hook = useHook((state, type) => {\r\n        if (HOOK_MOUNT == type) {\r\n            state[0] = initialState;\r\n            state[1] = action => {\r\n                let nextState = state[2](state[0], action);\r\n                if (nextState != state[0]) {\r\n                    state[0] = nextState;\r\n                    render();\r\n                }\r\n            };\r\n        }\r\n        return state;\r\n    }, []);\r\n    // allows the reduce to always access the scope of the component\r\n    hook[2] = reducer;\r\n\r\n    return hook;\r\n}\r\n/**\r\n * @todo add test use callback\r\n */\r\nfunction useCallback(callback, args) {\r\n    return useMemo(() => callback, args);\r\n}\n\nfunction useProp(name) {\r\n    let ref = useHost();\r\n    if (name in ref.current) {\r\n        if (!ref[name]) {\r\n            ref[name] = [null, nextValue => (ref.current[name] = nextValue)];\r\n        }\r\n        ref[name][0] = ref.current[name];\r\n        return ref[name];\r\n    }\r\n}\n\nfunction useEvent(type, customEventInit) {\r\n    let ref = useHost();\r\n    if (!ref[type]) {\r\n        ref[type] = detail =>\r\n            dispatchEvent(\r\n                ref.current,\r\n                type,\r\n                detail ? { ...customEventInit, detail } : customEventInit\r\n            );\r\n    }\r\n    return ref[type];\r\n}\n\nconst CACHE_STYLE_SHEET = {};\r\nconst CACHE_HASH_STYLE_SHEET = {};\r\n\r\nfunction useStyleSheet(...sheets) {\r\n    let { current } = useHost();\r\n    useEffect(() => {\r\n        let { shadowRoot } = current;\r\n        let setStyle = (id, cssText) => {\r\n            let style;\r\n            let query = `:scope > style#${id}`;\r\n            if (shadowRoot) {\r\n                style = shadowRoot.querySelector(query);\r\n                if (!style) {\r\n                    style = createNode(\"style\");\r\n                    insertNode(shadowRoot, style, null, true);\r\n                }\r\n            } else {\r\n                let root = current.getRootNode();\r\n                root = root == document ? document.head : root;\r\n                style = root.querySelector(`:scope > style#${id}`);\r\n                if (!style) {\r\n                    root.appendChild((style = createNode(\"style\")));\r\n                }\r\n            }\r\n            style.textContent = cssText;\r\n        };\r\n        if (shadowRoot && \"adoptedStyleSheets\" in document) {\r\n            shadowRoot.adoptedStyleSheets = sheets.map(cssText => {\r\n                if (cssText instanceof CSSStyleSheet) {\r\n                    return cssText;\r\n                }\r\n                if (!CACHE_STYLE_SHEET[cssText]) {\r\n                    CACHE_STYLE_SHEET[cssText] = new CSSStyleSheet();\r\n                    CACHE_STYLE_SHEET[cssText].replace(cssText);\r\n                }\r\n                return CACHE_STYLE_SHEET[cssText];\r\n            });\r\n            return;\r\n        }\r\n        sheets.forEach(cssText =>\r\n            setStyle(\r\n                (CACHE_HASH_STYLE_SHEET[cssText] =\r\n                    CACHE_HASH_STYLE_SHEET[cssText] || toHash(cssText)),\r\n                cssText\r\n            )\r\n        );\r\n    }, sheets);\r\n}\n\nconst WITH_DELEGATE_FOCUS = Symbol(\"delegateFocus\");\r\n\r\nfunction useDelegateFocus(ref) {\r\n    let { current } = useHost();\r\n    if (!current[WITH_DELEGATE_FOCUS]) {\r\n        current.tabIndex = 0;\r\n        current.addEventListener(\"focus\", () => {\r\n            current[WITH_DELEGATE_FOCUS].current.focus();\r\n        });\r\n    }\r\n    current[WITH_DELEGATE_FOCUS] = ref;\r\n}\n\nexport { ELEMENT_IGNORE_ATTR, ELEMENT_PROPS, customElement, createElement as h, render, toVnode, useCallback, useDelegateFocus, useEffect, useEvent, useHost, useMemo, useProp, useReducer, useRef, useState, useStyleSheet };\n//# sourceMappingURL=core.js.map\n","import { useState } from \"atomico\";\r\n\r\nlet globalHandlerCancel = [\r\n  \"touchend\",\r\n  \"mouseup\",\r\n  \"mouseleave\",\r\n  \"touchleave\",\r\n  \"click\"\r\n];\r\nlet globalHandlerCapture = [\"mousemove\", \"touchmove\"];\r\n\r\nfunction addEventListener(type, handler) {\r\n  window.addEventListener(type, handler);\r\n}\r\n\r\nfunction removeEventListener(type, handler) {\r\n  window.removeEventListener(type, handler);\r\n}\r\n\r\nexport function getSwipe(range, duration = 500, space = 100) {\r\n  let length = range.length;\r\n  let first = range[0];\r\n  let last = range[length - 1];\r\n  let [x, y] = range.reduce(([x, y], step) => [(x += step.x), (y += step.y)], [\r\n    0,\r\n    0\r\n  ]);\r\n  let ms = last.t - first.t;\r\n  if (ms < duration) {\r\n    let xD = first.x - last.x;\r\n\r\n    let dir = xD > 0 ? \"toRight\" : \"toLeft\";\r\n\r\n    if (Math.abs(xD) > 60) {\r\n      let yM = y / length;\r\n\r\n      let yMMax = yM + space / 2;\r\n      let yMMin = yM - space / 2;\r\n\r\n      let validZoneY = [first, last].every(({ y }) => y <= yMMax && y >= yMMin);\r\n      if (validZoneY) {\r\n        return dir;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {ObserverEventMove} callback\r\n */\r\nexport function useEventMove(callback) {\r\n  let [ref] = useState(() => {\r\n    function dispath(...args) {\r\n      return ref.callback(...args);\r\n    }\r\n    function startCapture(event) {\r\n      ref.capture = [];\r\n      globalHandlerCancel.forEach(type => addEventListener(type, endCapture));\r\n      globalHandlerCapture.forEach(type => addEventListener(type, capture));\r\n      capture(event, true);\r\n      dispath(\"start\", ref.capture);\r\n    }\r\n    function endCapture(event) {\r\n      if (!ref.capture) return;\r\n      capture(event, false);\r\n      let { capture: currentCapture } = ref;\r\n      ref.capture = false;\r\n      globalHandlerCancel.forEach(type =>\r\n        removeEventListener(type, endCapture)\r\n      );\r\n      globalHandlerCapture.forEach(type => removeEventListener(type, capture));\r\n      dispath(\"end\", currentCapture);\r\n    }\r\n    function capture(event, ignoreEmit) {\r\n      if (!ref.capture) return;\r\n      let x;\r\n      let y;\r\n\r\n      if (/touch/.test(event.type)) {\r\n        let touch = event.touches[0];\r\n        if (!touch) return;\r\n        x = touch.clientX;\r\n        y = touch.clientY;\r\n      } else {\r\n        x = event.clientX;\r\n        y = event.clientY;\r\n      }\r\n      ref.capture.push({ x, y, t: event.timeStamp });\r\n\r\n      if (!ignoreEmit) dispath(\"move\", ref.capture);\r\n    }\r\n\r\n    return {\r\n      slide: -1,\r\n      events: {\r\n        startCapture\r\n      }\r\n    };\r\n  });\r\n\r\n  ref.callback = callback;\r\n\r\n  return {\r\n    ref,\r\n    ontouchstart: ref.events.startCapture,\r\n    onmousedown: ref.events.startCapture\r\n  };\r\n}\r\n\r\n/**\r\n * @callback ObserverEventMove\r\n * @param {\"start\"|\"end\"|\"move\"} type - states associated with event capture\r\n * @param {Array.<{x:number,y:number,t:number}>} range - useful range of the associated movement\r\n * @return {{ref:{}}}\r\n */\r\n","import {\n  h,\n  useRef,\n  useHost,\n  useState,\n  useEffect,\n  customElement\n} from \"atomico\";\nimport { useEventMove } from \"../../hooks/use-event-move/use-event-move\";\nimport style from \"./a-showcase.css\";\n\nconst initialState = { loading: true, cases: [] };\n\nconst AShowcase = ({ src }) => {\n  const refSandbox = useRef();\n  const refPreview = useRef();\n  const refSelect = useRef();\n  const refHost = useHost();\n\n  const [state, setState] = useState(initialState);\n\n  let [select, setSelect] = useState();\n\n  let currentZone;\n\n  const propsMove = useEventMove((type, range) => {\n    if (type == \"start\") {\n      currentZone = refHost.current.getBoundingClientRect();\n    }\n    if (type == \"move\") {\n      const last = range[range.length - 1];\n      const move = last.x - currentZone.x;\n      const minWidth = refSelect.current\n        ? refSelect.current.clientWidth + 20\n        : 50;\n      const width =\n        ((move < minWidth ? minWidth : move) / currentZone.width) * 100;\n\n      refPreview.current.style.width =\n        (width > 100 ? 100 : width < 0 ? 0 : width) + \"%\";\n    }\n  });\n\n  useEffect(() => {\n    (async () => {\n      setState(state => (state.loading ? state : { ...state, loading: false }));\n\n      const { render, default: cases } = await import(\"./\" + src);\n\n      setState(state => ({\n        ...state,\n        loading: false,\n        cases,\n        render\n      }));\n    })();\n  }, [src]);\n\n  select = select || (state.cases[0] && state.cases[0].label);\n\n  useEffect(() => {\n    const { render, rendered } =\n      state.cases.find(({ label }) => label == select) || {};\n\n    render && state.render(render(), refSandbox.current);\n    rendered && rendered(refSandbox.current);\n  }, [state.cases, select]);\n\n  return (\n    <host shadowDom>\n      <style>{style}</style>\n      {state.cases.length > 1 && (\n        <select\n          ref={refSelect}\n          class=\"showcase -select\"\n          onchange={({ target }) => setSelect(target.value)}\n        >\n          {state.cases.map(({ label }) => (\n            <option selected={select == label} value={label}>\n              {label}\n            </option>\n          ))}\n        </select>\n      )}\n\n      <header></header>\n      <section class=\"showcase -preview\" ref={refPreview}>\n        <div class=\"showcase -sandbox\" ref={refSandbox}></div>\n        <button class=\"showcase -resize\" {...propsMove}></button>\n      </section>\n    </host>\n  );\n};\n\nAShowcase.props = {\n  width: {\n    type: String\n  },\n  height: {\n    type: String\n  },\n  src: {\n    type: String\n  },\n  centered: {\n    type: Boolean,\n    reflect: true\n  }\n};\n\nexport default customElement(\"a-showcase\", AShowcase);\n","import \"./a-showcase\";\r\n\r\ndescribe(\"a-shocase\", () => {\r\n  console.log(\"...init test\");\r\n  it(\"test\", () => {\r\n    let node = document.createElement(\"a-showcase\");\r\n    node();\r\n    document.body.appendChild(node);\r\n  });\r\n});\r\n"],"names":["globalHandlerCancel","globalHandlerCapture","addEventListener","type","handler","window","removeEventListener","useEventMove","callback","ref","useState","dispath","args","startCapture","event","capture","forEach","endCapture","currentCapture","ignoreEmit","x","y","test","touch","touches","clientX","clientY","push","t","timeStamp","slide","events","ontouchstart","onmousedown","initialState","loading","cases","AShowcase","src","refSandbox","useRef","refPreview","refSelect","refHost","useHost","state","setState","select","setSelect","currentZone","propsMove","range","current","getBoundingClientRect","last","length","move","minWidth","clientWidth","width","style","useEffect","render","default","label","rendered","find","h","target","value","map","props","String","height","centered","Boolean","reflect","customElement","describe","console","log","it","node","document","createElement","body","appendChild"],"mappings":"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"}