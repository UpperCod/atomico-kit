{"version":3,"file":"eaceffd6.js","sources":["../../node_modules/atomico/core.js"],"sourcesContent":["const HOOK_MOUNT = Symbol(\"mount\");\r\nconst HOOK_MOUNTED = Symbol(\"mounted\");\r\nconst HOOK_UPDATE = Symbol(\"update\");\r\nconst HOOK_UPDATED = Symbol(\"updated\");\r\nconst HOOK_UNMOUNT = Symbol(\"unmount\");\r\nconst HOOK_CURRENT = {};\r\n\r\nfunction update(hook, type) {\r\n    hook[0] && (hook[1] = hook[0](hook[1], type));\r\n}\r\n\r\nfunction updateAll(hooks, type) {\r\n    for (let i in hooks) update(hooks[i], type);\r\n}\r\n\r\nfunction useHook(reducer, initialState) {\r\n    if (HOOK_CURRENT.ref.hook) {\r\n        return HOOK_CURRENT.ref.hook.use(reducer, initialState)[1];\r\n    }\r\n}\r\n\r\nfunction useRender() {\r\n    return HOOK_CURRENT.ref.render;\r\n}\r\n\r\nfunction createHooks(render, host) {\r\n    let hooks = {};\r\n    let mounted;\r\n    let hook = {\r\n        use,\r\n        load,\r\n        updated,\r\n        unmount\r\n    };\r\n\r\n    let ref = { hook, host, render };\r\n\r\n    function load(callback, param) {\r\n        HOOK_CURRENT.index = 0;\r\n        HOOK_CURRENT.ref = ref;\r\n        let resolve = callback(param);\r\n        HOOK_CURRENT.ref = 0;\r\n        return resolve;\r\n    }\r\n    function use(reducer, state) {\r\n        let index = HOOK_CURRENT.index++;\r\n        let mount;\r\n        // record the hook and the initial state of this\r\n        if (!hooks[index]) {\r\n            hooks[index] = [null, state];\r\n            mount = 1;\r\n        }\r\n        // The hook always receives the last reduce.\r\n        hooks[index][0] = reducer;\r\n        update(hooks[index], mount ? HOOK_MOUNT : HOOK_UPDATE);\r\n        return hooks[index];\r\n    }\r\n    function updated() {\r\n        let type = mounted ? HOOK_UPDATED : HOOK_MOUNTED;\r\n        mounted = 1;\r\n        updateAll(hooks, type);\r\n    }\r\n    function unmount() {\r\n        updateAll(hooks, HOOK_UNMOUNT);\r\n    }\r\n    return hook;\r\n}\n\nconst ARRAY_EMPTY = [];\r\n\r\nconst NODE_HOST = \"host\";\r\n\r\nconst LIMIT_NODE = Symbol(\"limitNode\");\r\n\r\nconst IGNORE_CHILDREN = {\r\n    innerHTML: 1,\r\n    textContent: 1,\r\n    contenteditable: 1\r\n};\r\n\r\nconst JOIN_CHILDREN = {\r\n    style: 1\r\n};\r\n\r\nconst HYDRATE_PROPS = {\r\n    id: 1,\r\n    className: 1,\r\n    checked: 1,\r\n    value: 1,\r\n    selected: 1\r\n};\n\n/**\r\n * Return if value is array\r\n * @param {*}\r\n * @return {boolean}\r\n */\r\nconst isArray = value => Array.isArray(value);\r\n/**\r\n * compare 2 array\r\n * @param {array} before\r\n * @param {array} after\r\n * @example\r\n * isEqualArray([1,2,3,4],[1,2,3,4]) // true\r\n * isEqualArray([1,2,3,4],[1,2,3])   // false\r\n * isEqualArray([5,1,2,3],[1,2,3,5]) // false\r\n * isEqualArray([],[]) // true\r\n * @returns {boolean}\r\n */\r\nfunction isEqualArray(before, after) {\r\n    let length = before.length;\r\n    if (length !== after.length) return false;\r\n    for (let i = 0; i < length; i++) {\r\n        if (before[i] !== after[i]) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nconst isFunction = value => typeof value == \"function\";\r\n\r\n// export function fps(callback, count = 3) {\r\n//     count-- ? requestAnimationFrame(() => fps(callback, count)) : callback();\r\n// }\r\n\r\nconst promise = callback => new Promise(callback);\n\n/**\r\n *\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {Object} props\r\n * @param {Object} nextProps\r\n * @param {boolean} isSvg\r\n * @param {Object} handlers\r\n **/\r\nfunction diffProps(node, props, nextProps, isSvg, handlers) {\r\n    props = props || {};\r\n\r\n    for (let key in props) {\r\n        if (!(key in nextProps)) {\r\n            setProperty(node, key, props[key], null, isSvg, handlers);\r\n        }\r\n    }\r\n    let ignoreChildren;\r\n    for (let key in nextProps) {\r\n        setProperty(node, key, props[key], nextProps[key], isSvg, handlers);\r\n        ignoreChildren = ignoreChildren || IGNORE_CHILDREN[key];\r\n    }\r\n    return ignoreChildren;\r\n}\r\n\r\nfunction setProperty(node, key, prevValue, nextValue, isSvg, handlers) {\r\n    key = key == \"class\" && !isSvg ? \"className\" : key;\r\n    // define empty value\r\n    prevValue = prevValue == null ? null : prevValue;\r\n    nextValue = nextValue == null ? null : nextValue;\r\n\r\n    if (key in node && HYDRATE_PROPS[key]) {\r\n        prevValue = node[key];\r\n    }\r\n\r\n    if (nextValue === prevValue) return;\r\n\r\n    if (\r\n        key[0] == \"o\" &&\r\n        key[1] == \"n\" &&\r\n        (isFunction(nextValue) || isFunction(prevValue))\r\n    ) {\r\n        setEvent(node, key, nextValue, handlers);\r\n        return;\r\n    }\r\n\r\n    switch (key) {\r\n        case \"key\":\r\n            node.dataset.key = nextValue;\r\n            break;\r\n        case \"ref\":\r\n            if (nextValue) nextValue.current = node;\r\n            break;\r\n        case \"style\":\r\n            setStyle(node, prevValue || \"\", nextValue || \"\");\r\n            break;\r\n        default:\r\n            if (!isSvg && key != \"list\" && key in node) {\r\n                node[key] = nextValue == null ? \"\" : nextValue;\r\n            } else if (nextValue == null) {\r\n                node.removeAttribute(key);\r\n            } else {\r\n                node.setAttribute(\r\n                    key,\r\n                    typeof nextValue == \"object\"\r\n                        ? JSON.stringify(nextValue)\r\n                        : nextValue\r\n                );\r\n            }\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {string} type\r\n * @param {function} [nextHandler]\r\n * @param {object} handlers\r\n */\r\nfunction setEvent(node, type, nextHandler, handlers) {\r\n    // get the name of the event to use\r\n    type = type.slice(type[2] == \"-\" ? 3 : 2);\r\n    // add handleEvent to handlers\r\n    if (!handlers.handleEvent) {\r\n        /**\r\n         * {@link https://developer.mozilla.org/es/docs/Web/API/EventTarget/addEventListener#The_value_of_this_within_the_handler}\r\n         **/\r\n        handlers.handleEvent = event => handlers[event.type].call(node, event);\r\n    }\r\n    if (nextHandler) {\r\n        // create the subscriber if it does not exist\r\n        if (!handlers[type]) {\r\n            node.addEventListener(type, handlers);\r\n        }\r\n        // update the associated event\r\n        handlers[type] = nextHandler;\r\n    } else {\r\n        // \tdelete the associated event\r\n        if (handlers[type]) {\r\n            node.removeEventListener(type, handlers);\r\n            delete handlers[type];\r\n        }\r\n    }\r\n}\r\n/**\r\n * define style as string inline,this generates less mutation\r\n * to the sun and cleans the previously defined properties.\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {(string|object)} prevValue\r\n * @param {(string|object)} nextValue\r\n */\r\nfunction setStyle(node, prevValue, nextValue) {\r\n    let style = node.style,\r\n        prevIsObject;\r\n    if (typeof prevValue == \"object\") {\r\n        prevIsObject = true;\r\n        for (let key in prevValue) {\r\n            if (!(key in nextValue)) setPropertyStyle(style, key, null);\r\n        }\r\n    }\r\n    if (typeof nextValue == \"object\") {\r\n        for (let key in nextValue) {\r\n            let value = nextValue[key];\r\n            if (prevIsObject && prevValue[key] === value) continue;\r\n            setPropertyStyle(style, key, value);\r\n        }\r\n    } else {\r\n        style.cssText = nextValue;\r\n    }\r\n}\r\n\r\nfunction setPropertyStyle(style, key, value) {\r\n    let method = \"setProperty\";\r\n    if (value == null) {\r\n        method = \"removeProperty\";\r\n        value = null;\r\n    }\r\n    if (~key.indexOf(\"-\")) {\r\n        style[method](key, value);\r\n    } else {\r\n        style[key] = value;\r\n    }\r\n}\n\nlet vNodeEmpty = createElement(null, { children: \"\" });\r\n\r\nlet vNodeFill = createElement(null, { children: ARRAY_EMPTY });\r\n\r\nconst META_MAP_CHILDREN = Symbol(\"mapChildren\");\r\n\r\nconst META_KEYES = Symbol(\"keyes\");\r\n/**\r\n * @param {VnodeType} nodeType\r\n * @param {VnodeProps} [props]\r\n * @param {Vnode|Vnode[]} [children]\r\n * @returns {Vnode}\r\n **/\r\nfunction createElement(nodeType, props, ...children) {\r\n    return { children, ...props, nodeType: nodeType || null };\r\n}\r\n/**\r\n * toVnode, processes the object for correct use within the diff process.\r\n **/\r\nfunction toVnode(value) {\r\n    if (isVnodeValue(value)) {\r\n        return value;\r\n    } else {\r\n        // this process occurs only once per vnode\r\n        if (!value[META_MAP_CHILDREN]) {\r\n            let { children, keyes } = mapChildren(value.children);\r\n            value.children = children.length ? children : ARRAY_EMPTY;\r\n            if (keyes && keyes.length == children.length) {\r\n                value[META_KEYES] = keyes;\r\n            }\r\n            value[META_MAP_CHILDREN] = true;\r\n        }\r\n    }\r\n    return value;\r\n}\r\n\r\nfunction mapChildren(children, scan = { children: [] }, deep = 0) {\r\n    if (isArray(children)) {\r\n        let length = children.length;\r\n        for (let i = 0; i < length; i++) {\r\n            mapChildren(children[i], scan, deep + 1);\r\n        }\r\n    } else {\r\n        if (children == null && !deep) return scan;\r\n\r\n        let vnode = toVnode(children);\r\n\r\n        if (vnode != null && typeof vnode == \"object\") {\r\n            if (isFunction(vnode.nodeType)) {\r\n                let { nodeType, ...props } = vnode;\r\n                return mapChildren(nodeType(props), scan, deep + 1);\r\n            }\r\n            let { key } = vnode;\r\n            if (key != null) {\r\n                key += \"\";\r\n                scan.keyes = scan.keyes || [];\r\n                if (!scan.keyes.includes(key)) {\r\n                    scan.keyes.push(key);\r\n                }\r\n            }\r\n        }\r\n\r\n        scan.children.push(vnode);\r\n    }\r\n    return scan;\r\n}\r\n\r\nfunction isVnodeEmpty(value) {\r\n    let type = typeof value;\r\n    return value == null || type == \"boolean\" || type == \"function\";\r\n}\r\n\r\nfunction fillVnodeValue(value) {\r\n    return isVnodeEmpty(value)\r\n        ? vNodeEmpty\r\n        : createElement(null, { children: \"\" + value });\r\n}\r\n\r\nfunction isVnodeValue(value) {\r\n    let type = typeof value;\r\n    return (\r\n        value == null ||\r\n        type == \"string\" ||\r\n        type == \"number\" ||\r\n        type == \"function\" ||\r\n        type == \"boolean\"\r\n    );\r\n}\r\n\r\n/**\r\n * @typedef {(Object<string,any>)} VnodeProps;\r\n *\r\n * @typedef {(Function|string)} VnodeType;\r\n *\r\n * @typedef {{type:VnodeType,props:VnodeProps}} Vnode\r\n **/\n\nconst isRawNode = node => node instanceof Node;\r\n\r\nconst createLimitNode = parent =>\r\n    (parent[LIMIT_NODE] = parent.appendChild(new Comment()));\r\n/**\r\n *\r\n * @param {string} type\r\n * @param {boolean} isSvg\r\n * @returns {import(\"./render\").HTMLNode}\r\n */\r\nfunction createNode(type, isSvg, is) {\r\n    let doc = document;\r\n    let nextNode;\r\n    if (type != null) {\r\n        if (isRawNode(type)) {\r\n            return type;\r\n        }\r\n        nextNode = isSvg\r\n            ? doc.createElementNS(\"http://www.w3.org/2000/svg\", type)\r\n            : doc.createElement(type, is ? { is } : null);\r\n    } else {\r\n        nextNode = doc.createTextNode(\"\");\r\n    }\r\n    return nextNode;\r\n}\r\n/**\r\n * compare 2 nodes, to define if these are equal\r\n * @param {string|null|HTMLElement|SVGElement} nodeA\r\n * @param {string|null|HTMLElement|SVGElement} nodeB\r\n */\r\nfunction equalNode(nodeA, nodeB) {\r\n    let isRawA = nodeA && isRawNode(nodeA);\r\n    let isRawB = nodeB && isRawNode(nodeB);\r\n    if (isRawB && isRawA) {\r\n        return isRawB == isRawB;\r\n    }\r\n    if (nodeA) {\r\n        if (!nodeA.localName) {\r\n            nodeA.localName = nodeA.nodeName.toLowerCase();\r\n        }\r\n\r\n        let localName = nodeA.localName;\r\n        return (localName == \"#text\" ? null : localName) == nodeB;\r\n    }\r\n}\r\n\r\nfunction insertNode(parent, newNode, beforeNode, afterLimit) {\r\n    let limitNode = parent[LIMIT_NODE];\r\n\r\n    if (!limitNode) {\r\n        let { childNodes } = parent;\r\n        let length = childNodes.length;\r\n        for (let i = 0; i < length; i++) {\r\n            let child = childNodes[length];\r\n            if (child instanceof Comment) {\r\n                limitNode = child;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!limitNode) limitNode = createLimitNode(parent);\r\n\r\n    parent[afterLimit ? \"appendChild\" : \"insertBefore\"](\r\n        newNode,\r\n        beforeNode || limitNode\r\n    );\r\n}\n\n/**\r\n *\r\n * @param {import(\"./render\").ConfigRender} config\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {import(\"./vnode\").Vnode} nextVnode\r\n * @param {boolean} isSvg\r\n * @param {Function} currentUpdateComponent\r\n * @return {import(\"./render\").HTMLNode}\r\n **/\r\nfunction diff(id, node, nextVnode, isSvg) {\r\n    let { vnode, handlers = {} } = (node && node[id]) || {};\r\n\r\n    if (vnode == nextVnode && vnode != null) return node;\r\n\r\n    nextVnode = isVnodeValue(nextVnode) ? fillVnodeValue(nextVnode) : nextVnode;\r\n\r\n    let { nodeType, shadowDom, children, is, ...props } = vnode || vNodeFill;\r\n\r\n    let {\r\n        nodeType: nextNodeType,\r\n        shadowDom: nextShadowDom,\r\n        children: nextChildren,\r\n        is: nextIs,\r\n        ...nextProps\r\n    } = nextVnode;\r\n\r\n    isSvg = isSvg || nextNodeType == \"svg\";\r\n\r\n    if (\r\n        nextNodeType != NODE_HOST &&\r\n        (!equalNode(node, nextNodeType) || is != nextIs)\r\n    ) {\r\n        let nextNode = createNode(nextNodeType, isSvg, nextIs);\r\n        let parent = node && node.parentNode;\r\n        if (parent) {\r\n            parent.replaceChild(nextNode, node);\r\n        }\r\n\r\n        node = nextNode;\r\n        handlers = {};\r\n    }\r\n\r\n    if (JOIN_CHILDREN[nextNodeType]) {\r\n        nextNodeType = null;\r\n        nextChildren = nextChildren.join(\"\");\r\n    }\r\n    if (nextNodeType == null) {\r\n        if (node.textContent != nextChildren) {\r\n            node.textContent = nextChildren;\r\n        }\r\n    } else {\r\n        if (shadowDom != nextShadowDom) {\r\n            let { shadowRoot } = node;\r\n            let mode =\r\n                nextShadowDom && !shadowRoot\r\n                    ? \"open\"\r\n                    : !nextShadowDom && shadowRoot\r\n                    ? \"closed\"\r\n                    : 0;\r\n            if (mode) node.attachShadow({ mode });\r\n        }\r\n\r\n        let ignoreChildren = diffProps(\r\n            node,\r\n            props,\r\n            nextProps,\r\n            isSvg,\r\n            handlers);\r\n\r\n        if (!ignoreChildren && children != nextChildren) {\r\n            diffChildren(\r\n                id,\r\n                nextShadowDom ? node.shadowRoot : node,\r\n                nextChildren,\r\n                nextProps[META_KEYES],\r\n                isSvg\r\n            );\r\n        }\r\n    }\r\n    node[id] = { vnode: nextVnode, handlers };\r\n    return node;\r\n}\r\n/**\r\n *\r\n * @param {import(\"./render\").ConfigRender} config\r\n * @param {import(\"./render\").HTMLNode} parent\r\n * @param {import(\"./vnode\").Vnode[]} [nextChildren]\r\n * @param {boolean} isSvg\r\n */\r\nfunction diffChildren(id, parent, children, keyes, isSvg) {\r\n    let childrenLenght = children.length;\r\n    let { childNodes } = parent;\r\n    let childNodesKeyes = {};\r\n    let childNodesLength = childNodes.length;\r\n    let index = 0;\r\n    // limit Atomico's reach only to the comment marker\r\n    let limitNode = parent[LIMIT_NODE];\r\n\r\n    for (; index < childNodesLength; index++) {\r\n        let childNode = childNodes[index];\r\n        if (childNode == limitNode || childNode instanceof Comment) {\r\n            limitNode = childNode;\r\n            break;\r\n        }\r\n        if (keyes) {\r\n            let key = childNode.dataset.key;\r\n            if (keyes.includes(key)) {\r\n                childNodesKeyes[key] = childNode;\r\n                continue;\r\n            }\r\n        }\r\n\r\n        if (keyes || index >= childrenLenght) {\r\n            index--;\r\n            childNodesLength--;\r\n            childNode.remove();\r\n        }\r\n    }\r\n    // If you don't find a bookmark in the list, you create it.\r\n    if (!limitNode) limitNode = createLimitNode(parent);\r\n\r\n    for (let i = 0; i < childrenLenght; i++) {\r\n        let child = children[i];\r\n        let indexChildNode = i == index ? null : childNodes[i];\r\n        let key = keyes ? child.key : i;\r\n        let childNode = keyes ? childNodesKeyes[key] : indexChildNode;\r\n\r\n        if (keyes && childNode) {\r\n            if (childNode != indexChildNode) {\r\n                parent.insertBefore(childNode, indexChildNode);\r\n            }\r\n        }\r\n\r\n        let nextChildNode = diff(id, childNode, child, isSvg);\r\n\r\n        if (!childNode) {\r\n            insertNode(\r\n                parent,\r\n                nextChildNode,\r\n                i == index ? limitNode : childNodes[i]\r\n            );\r\n            // increase the limit position since a new node has been inserted\r\n            index++;\r\n        }\r\n    }\r\n}\n\nfunction render(vnode, node, id = \"vnode\") {\r\n    if (\r\n        vnode != null &&\r\n        typeof vnode == \"object\" &&\r\n        vnode.nodeType != NODE_HOST\r\n    ) {\r\n        vnode = createElement(NODE_HOST, { children: vnode });\r\n    }\r\n    vnode = toVnode(vnode);\r\n    diff(id, node, vnode);\r\n    return node;\r\n}\n\nconst TRUE_VALUES = [true, 1, \"\", \"1\", \"true\"];\r\n\r\nconst Any = null;\r\n\r\nfunction formatType(value, type) {\r\n    if (type == Any) return { value };\r\n\r\n    try {\r\n        if (type == Boolean) {\r\n            value = TRUE_VALUES.includes(value);\r\n        } else if (typeof value == \"string\") {\r\n            value =\r\n                type == Number\r\n                    ? Number(value)\r\n                    : type == Object || type == Array\r\n                    ? JSON.parse(value)\r\n                    : value;\r\n        }\r\n        if ({}.toString.call(value) == `[object ${type.name}]`) {\r\n            return { value, error: type == Number && Number.isNaN(value) };\r\n        }\r\n    } catch (e) {}\r\n\r\n    return { value, error: true };\r\n}\r\n\r\nconst setAttr = (node, attr, value) =>\r\n    value == null\r\n        ? node.removeAttribute(attr)\r\n        : node.setAttribute(\r\n              attr,\r\n              typeof value == \"object\" ? JSON.stringify(value) : value\r\n          );\r\n\r\nconst propToAttr = prop => prop.replace(/([A-Z])/g, \"-$1\").toLowerCase();\r\n\r\nconst attrToProp = attr =>\r\n    attr.replace(/-(\\w)/g, (all, letter) => letter.toUpperCase());\r\n\r\nconst dispatchEvent = (node, type, customEventInit) =>\r\n    node.dispatchEvent(\r\n        new CustomEvent(\r\n            type,\r\n            typeof customEventInit == \"object\" ? customEventInit : null\r\n        )\r\n    );\r\n\r\nconst createPropError = (status, message) =>\r\n    Object.assign(new Error(\"Failed prop\\n\" + message), status);\n\nconst defer = callback => Promise.resolve().then(callback);\r\nconst maxFps = 1000 / 60;\r\n\r\nlet queue = [];\r\nlet running;\r\n\r\nconst IMPORTANT = Symbol(\"important\");\r\n\r\nfunction clearQueue() {\r\n    let time = performance.now();\r\n\r\n    let length = queue.length;\r\n    let current = queue;\r\n\r\n    queue = [];\r\n\r\n    while (length--) {\r\n        let callback = current[length];\r\n        // if in case one is defined as important, the execution will be forced\r\n        if (callback[IMPORTANT] || performance.now() - time < maxFps) {\r\n            callback();\r\n        } else {\r\n            queue = queue.concat(current.slice(0, length + 1));\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (queue.length) {\r\n        requestAnimationFrame(clearQueue);\r\n        return;\r\n    }\r\n    running = false;\r\n}\r\n/**\r\n * add a task to the queue\r\n * @param {Function} callback\r\n * @returns {Promise} Generate a promise that show  if the queue is complete\r\n */\r\nfunction addQueue(callback) {\r\n    if (!running) {\r\n        running = true;\r\n        defer(clearQueue);\r\n    }\r\n    // if the callback is defined as IMPORTANT,\r\n    // it is assumed to be in favor of the tree\r\n    // of the DOM  that must be added by unshift,\r\n    // assuming that the mount will be carried\r\n    // out in order, the shift priority only works\r\n    // after the first render\r\n    if (!queue.includes(callback))\r\n        queue[callback[IMPORTANT] ? \"unshift\" : \"push\"](callback);\r\n}\n\nconst ELEMENT_PROPS = Symbol(\"props\");\r\nconst ELEMENT_IGNORE_ATTR = Symbol(\"ignore\");\r\n\r\nfunction load(target, componentRender, componentError) {\r\n    if (target.mount) return;\r\n\r\n    let id = Symbol(\"vnode\");\r\n\r\n    let isPrevent;\r\n    let isUnmount;\r\n\r\n    target[ELEMENT_PROPS] = {};\r\n\r\n    let isMounted;\r\n\r\n    let resolveUpdate;\r\n\r\n    let rerender = () => {\r\n        // disables blocking, allowing the cycle to be regenerate\r\n        isPrevent = false;\r\n        // After the first render it disables the important condition\r\n        if (rerender[IMPORTANT]) rerender[IMPORTANT] = false;\r\n        try {\r\n            render(\r\n                hooks.load(componentRender, { ...target[ELEMENT_PROPS] }),\r\n                target,\r\n                id\r\n            );\r\n\r\n            resolveUpdate();\r\n        } catch (e) {\r\n            (componentError || console.error)(e);\r\n        }\r\n    };\r\n    // mark the first render as important, target speeds up the rendering\r\n    rerender[IMPORTANT] = true;\r\n\r\n    target.update = () => {\r\n        if (isUnmount) return;\r\n        let rendered = target.rendered;\r\n        if (!isPrevent) {\r\n            isPrevent = true;\r\n            // create a promise to observe the status of the update\r\n            rendered = promise(resolve => (resolveUpdate = resolve)).then(\r\n                // the UPDATED state is only propagated through\r\n                // the resolution of the promise\r\n                // Why? ... to improve communication between web-component parent and children\r\n                hooks.updated\r\n            );\r\n\r\n            // if the component is already mounted, avoid using target.mounted,\r\n            // to speed up the microtask\r\n            isMounted\r\n                ? addQueue(rerender)\r\n                : target.mounted.then(() => {\r\n                      isMounted = true;\r\n                      addQueue(rerender);\r\n                  });\r\n        }\r\n\r\n        return (target.rendered = rendered);\r\n    };\r\n\r\n    // any update from hook is added to a separate queue\r\n    let hooks = createHooks(() => addQueue(target.update), target);\r\n\r\n    // creates a collection of microtask\r\n    // associated with the mounted of the component\r\n\r\n    target.mounted = promise(\r\n        resolve =>\r\n            (target.mount = () => {\r\n                isMounted = false;\r\n                // allows the reuse of the component when it is isUnmounted and mounted\r\n                if (isUnmount == true) {\r\n                    isUnmount = false;\r\n                    target.mounted = target.update();\r\n                }\r\n                resolve();\r\n            })\r\n    );\r\n    /**\r\n     * creates a collection of microtask\r\n     * associated with the unmounted of the component\r\n     */\r\n    target.unmounted = promise(\r\n        resolve =>\r\n            (target.unmount = () => {\r\n                isUnmount = true;\r\n                hooks.unmount();\r\n                resolve();\r\n            })\r\n    );\r\n\r\n    target.initialize();\r\n\r\n    target.update();\r\n}\r\n\r\n/**\r\n * register the component, be it a class or function\r\n * @param {string} nodeType\r\n * @param {Function} component\r\n * @return {Function} returns a jsx component\r\n */\r\nfunction customElement(nodeType, component, options) {\r\n    if (isFunction(nodeType)) {\r\n        // By defining nodeType as a function, custom ELement\r\n        // allows the assignment of a constructor to be extended\r\n        let BaseElement = component || HTMLElement;\r\n\r\n        component = nodeType;\r\n\r\n        let { props, error } = component;\r\n\r\n        /**@type {Function[]}*/\r\n        let initialize = [];\r\n\r\n        /**@type {string[]} */\r\n        let attrs = [];\r\n\r\n        let CustomElement = class extends BaseElement {\r\n            constructor() {\r\n                super();\r\n                /**\r\n                 * identifier to store the virtual-dom state,\r\n                 * this is unique between instances of the\r\n                 * component to securely consider the host status\r\n                 */\r\n                load(this, component, error);\r\n            }\r\n            connectedCallback() {\r\n                load(this, component, error);\r\n                this.mount();\r\n            }\r\n            disconnectedCallback() {\r\n                this.unmount();\r\n            }\r\n            attributeChangedCallback(attr, oldValue, value) {\r\n                if (attr === this[ELEMENT_IGNORE_ATTR] || oldValue === value)\r\n                    return;\r\n                this[attrToProp(attr)] = value;\r\n            }\r\n            initialize() {\r\n                let length = initialize.length;\r\n                while (length--) initialize[length](this);\r\n            }\r\n        };\r\n\r\n        let prototype = CustomElement.prototype;\r\n\r\n        for (let prop in props)\r\n            setProperty$1(prototype, initialize, attrs, prop, props[prop]);\r\n\r\n        CustomElement.observedAttributes = attrs;\r\n\r\n        CustomElement.props = props;\r\n\r\n        return CustomElement;\r\n    } else {\r\n        let { base, ...opts } = options || {};\r\n        let define = () =>\r\n            customElements.define(\r\n                nodeType,\r\n                customElement(component, base),\r\n                opts\r\n            );\r\n        // it allows to wait for one or more webcomponents\r\n        // to be defined before the definition of this\r\n        opts.waitFor\r\n            ? Promise.all(\r\n                  []\r\n                      .concat(opts.waitFor)\r\n                      .map(nodeType => customElements.whenDefined(nodeType))\r\n              ).then(define)\r\n            : define();\r\n        return props =>\r\n            opts.extends\r\n                ? createElement(opts.extends, { ...props, is: nodeType })\r\n                : createElement(nodeType, props);\r\n    }\r\n}\r\n\r\nfunction setProperty$1(prototype, initialize, attrs, prop, schema) {\r\n    // avoid rewriting the prototype\r\n    if (prop in prototype) return;\r\n\r\n    let attr = propToAttr(prop);\r\n\r\n    schema = schema == Any || schema.name ? { type: schema } : schema;\r\n\r\n    let isNotCallable = schema.type == Function || schema.type == Any;\r\n\r\n    function set(nextValue) {\r\n        let prevValue = this[ELEMENT_PROPS][prop];\r\n        // if the next value in function, with the exception of the type function or Any,\r\n        // will be executed to get the next value\r\n        if (!isNotCallable && isFunction(nextValue)) {\r\n            nextValue = nextValue(prevValue);\r\n        }\r\n        // Evaluate the defined type, to work with the value or issue an error\r\n        let { value, error } = formatType(nextValue, schema.type);\r\n\r\n        // define if the definition of prop has generated a type error\r\n        if (error && value != null) {\r\n            throw createPropError(\r\n                {\r\n                    target: this,\r\n                    schema,\r\n                    value\r\n                },\r\n                `The value defined for prop '${prop}' must be of type '${schema.type.name}'`\r\n            );\r\n        }\r\n        // define if the prop definition has generated an options error\r\n        if (schema.options && !schema.options.includes(value)) {\r\n            throw createPropError(\r\n                {\r\n                    target: this,\r\n                    schema,\r\n                    value\r\n                },\r\n                `The value defined for prop '${prop}' It is not a valid option`\r\n            );\r\n        }\r\n\r\n        if (prevValue == value) return;\r\n\r\n        this[ELEMENT_PROPS][prop] = value;\r\n\r\n        let rendered = this.update();\r\n\r\n        if (schema.event) {\r\n            // The event is only dispatched if the component has finished\r\n            // the rendering cycle, this is useful to observe the changes\r\n            rendered.then(() =>\r\n                dispatchEvent(this, schema.event.type || prop, schema.event)\r\n            );\r\n        }\r\n\r\n        if (schema.reflect) {\r\n            // the default properties are only reflected once the web-component is mounted\r\n            this.mounted.then(() => {\r\n                this[ELEMENT_IGNORE_ATTR] = attr; //update is prevented\r\n                setAttr(\r\n                    this,\r\n                    attr,\r\n                    schema.type == Boolean && !value ? null : value //\r\n                );\r\n                this[ELEMENT_IGNORE_ATTR] = false; // an upcoming update is allowed\r\n            });\r\n        }\r\n    }\r\n\r\n    function get() {\r\n        return this[ELEMENT_PROPS][prop];\r\n    }\r\n\r\n    Object.defineProperty(prototype, prop, { set, get });\r\n\r\n    if (\"value\" in schema) {\r\n        initialize.push(target => {\r\n            let { value } = schema;\r\n            target[ELEMENT_PROPS][prop] = isFunction(value) ? value() : value;\r\n        });\r\n    }\r\n    attrs.push(attr);\r\n}\n\nfunction useHost() {\r\n    return useHook(0, { current: HOOK_CURRENT.ref.host });\r\n}\r\n\r\nfunction useState(initialState) {\r\n    let render = useRender();\r\n    return useHook((state, type) => {\r\n        if (HOOK_MOUNT == type) {\r\n            state[0] = isFunction(initialState) ? initialState() : initialState;\r\n            state[1] = nextState => {\r\n                nextState = isFunction(nextState)\r\n                    ? nextState(state[0])\r\n                    : nextState;\r\n                if (nextState != state[0]) {\r\n                    state[0] = nextState;\r\n                    render();\r\n                }\r\n            };\r\n        }\r\n        return state;\r\n    }, []);\r\n}\r\n\r\nfunction useEffect(callback, args) {\r\n    // define whether the effect in the render cycle should be regenerated\r\n    let executeEffect;\r\n    useHook((state, type) => {\r\n        if (executeEffect == null) {\r\n            executeEffect =\r\n                args && state[0] ? !isEqualArray(args, state[0]) : true;\r\n            state[0] = args;\r\n        }\r\n\r\n        switch (type) {\r\n            case HOOK_UPDATE:\r\n            case HOOK_UNMOUNT:\r\n                // save the current args, for comparison\r\n                if ((executeEffect || type == HOOK_UNMOUNT) && state[1]) {\r\n                    // compare the previous snapshot with the generated state\r\n                    state[1]();\r\n                    // clean the effect collector\r\n                    state[1] = 0;\r\n                }\r\n                // delete the previous argument for a hook\r\n                // run if the hook is inserted in a new node\r\n                // Why? ... to perform again dom operations associated with the parent\r\n                if (type == HOOK_UNMOUNT) {\r\n                    state[0] = null;\r\n                }\r\n                break;\r\n            case HOOK_MOUNTED:\r\n            case HOOK_UPDATED:\r\n                // save the current args, for comparison, repeats due to additional type HOOK_MOUNTED\r\n                if (executeEffect || type == HOOK_MOUNTED) {\r\n                    // save the effect collector\r\n                    state[1] = callback();\r\n                }\r\n                // save the comparison argument\r\n                break;\r\n        }\r\n        return state;\r\n    }, []);\r\n}\r\n\r\nfunction useRef(current) {\r\n    return useHook(0, { current });\r\n}\r\n\r\nfunction useMemo(callback, args) {\r\n    let state = useHook(0, []);\r\n\r\n    if (!state[0] || (state[0] && (!args || !isEqualArray(state[0], args)))) {\r\n        state[1] = callback();\r\n    }\r\n    state[0] = args;\r\n    return state[1];\r\n}\r\n\r\nfunction useReducer(reducer, initialState) {\r\n    let render = useRender();\r\n    let hook = useHook((state, type) => {\r\n        if (HOOK_MOUNT == type) {\r\n            state[0] = initialState;\r\n            state[1] = action => {\r\n                let nextState = state[2](state[0], action);\r\n                if (nextState != state[0]) {\r\n                    state[0] = nextState;\r\n                    render();\r\n                }\r\n            };\r\n        }\r\n        return state;\r\n    }, []);\r\n    // allows the reduce to always access the scope of the component\r\n    hook[2] = reducer;\r\n\r\n    return hook;\r\n}\r\n/**\r\n * @todo add test use callback\r\n */\r\nfunction useCallback(callback, args) {\r\n    return useMemo(() => callback, args);\r\n}\n\nfunction useProp(name) {\r\n    let ref = useHost();\r\n    if (name in ref.current) {\r\n        if (!ref[name]) {\r\n            ref[name] = [null, nextValue => (ref.current[name] = nextValue)];\r\n        }\r\n        ref[name][0] = ref.current[name];\r\n        return ref[name];\r\n    }\r\n}\n\nfunction useEvent(type, customEventInit) {\r\n    let ref = useHost();\r\n    if (!ref[type]) {\r\n        ref[type] = detail =>\r\n            dispatchEvent(\r\n                ref.current,\r\n                type,\r\n                detail ? { ...customEventInit, detail } : customEventInit\r\n            );\r\n    }\r\n    return ref[type];\r\n}\n\nexport { Any, customElement, createElement as h, render, toVnode, useCallback, useEffect, useEvent, useHost, useMemo, useProp, useReducer, useRef, useState };\n//# sourceMappingURL=core.js.map\n"],"names":["HOOK_MOUNT","Symbol","HOOK_MOUNTED","HOOK_UPDATE","HOOK_UPDATED","HOOK_UNMOUNT","HOOK_CURRENT","update","hook","type","updateAll","hooks","i","useHook","reducer","initialState","ref","use","render","host","mounted","state","mount","index","load","callback","param","resolve","updated","unmount"],"mappings":"AAAO,MAAMA,EAAaC,OAAO,SACpBC,EAAeD,OAAO,WACtBE,EAAcF,OAAO,UACrBG,EAAeH,OAAO,WACtBI,EAAeJ,OAAO,WACtBK,EAAe,GAE5B,SAASC,EAAOC,EAAMC,GAClBD,EAAK,KAAOA,EAAK,GAAKA,EAAK,GAAGA,EAAK,GAAIC,IAG3C,SAASC,EAAUC,EAAOF,OACjB,IAAIG,KAAKD,EAAOJ,EAAOI,EAAMC,GAAIH,GAGnC,SAASI,EAAQC,EAASC,MACzBT,EAAaU,IAAIR,YACVF,EAAaU,IAAIR,KAAKS,IAAIH,EAASC,GAAc,kkJAQzD,SAAqBG,EAAQC,OAE5BC,EADAT,EAAQ,GAERH,EAAO,CACPS,aAeSH,EAASO,OAEdC,EADAC,EAAQjB,EAAaiB,QAGpBZ,EAAMY,KACPZ,EAAMY,GAAS,CAAC,KAAMF,GACtBC,EAAQ,UAGZX,EAAMY,GAAO,GAAKT,EAClBP,EAAOI,EAAMY,GAAQD,EAAQtB,EAAaG,GACnCQ,EAAMY,IAzBbC,cAOUC,EAAUC,GACpBpB,EAAaiB,MAAQ,EACrBjB,EAAaU,IAAMA,MACfW,EAAUF,EAASC,UACvBpB,EAAaU,IAAM,EACZW,GAXPC,uBA2BInB,EAAOW,EAAUhB,EAAeF,EACpCkB,EAAU,EACVV,EAAUC,EAAOF,IA5BjBoB,mBA+BAnB,EAAUC,EAAON,KA5BjBW,EAAM,CAAER,KAAAA,EAAMW,KAAAA,EAAMD,OAAAA,UA8BjBV,olEA3CAF,EAAaU,IAAIE"}