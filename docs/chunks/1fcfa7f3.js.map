{"version":3,"file":"1fcfa7f3.js","sources":["../../node_modules/atomico/core.js"],"sourcesContent":["const HOOK_MOUNT = 1; //Symbol(\"mount\");\r\nconst HOOK_MOUNTED = 2; //Symbol(\"mounted\");\r\nconst HOOK_UPDATE = 3; //Symbol(\"update\");\r\nconst HOOK_UPDATED = 4; //Symbol(\"updated\");\r\nconst HOOK_UNMOUNT = 5; //Symbol(\"unmount\");\r\nconst HOOK_CURRENT = {};\r\n\r\nfunction update(hook, type) {\r\n    hook[0] && (hook[1] = hook[0](hook[1], type));\r\n}\r\n\r\nfunction updateAll(hooks, type) {\r\n    for (let i in hooks) update(hooks[i], type);\r\n}\r\n\r\nfunction useHook(reducer, initialState) {\r\n    if (HOOK_CURRENT.ref.hook) {\r\n        return HOOK_CURRENT.ref.hook.use(reducer, initialState)[1];\r\n    }\r\n}\r\n\r\nfunction useRender() {\r\n    return HOOK_CURRENT.ref.render;\r\n}\r\n\r\nfunction createHooks(render, host) {\r\n    let hooks = {};\r\n    let mounted;\r\n    let hook = {\r\n        use,\r\n        load,\r\n        updated,\r\n        unmount,\r\n    };\r\n\r\n    let ref = { hook, host, render };\r\n\r\n    function load(callback, param) {\r\n        HOOK_CURRENT.index = 0;\r\n        HOOK_CURRENT.ref = ref;\r\n        let resolve = callback(param);\r\n        HOOK_CURRENT.ref = 0;\r\n        return resolve;\r\n    }\r\n    function use(reducer, state) {\r\n        let index = HOOK_CURRENT.index++;\r\n        let mount;\r\n        // record the hook and the initial state of this\r\n        if (!hooks[index]) {\r\n            hooks[index] = [null, state];\r\n            mount = 1;\r\n        }\r\n        // The hook always receives the last reduce.\r\n        hooks[index][0] = reducer;\r\n        update(hooks[index], mount ? HOOK_MOUNT : HOOK_UPDATE);\r\n        return hooks[index];\r\n    }\r\n    function updated() {\r\n        let type = mounted ? HOOK_UPDATED : HOOK_MOUNTED;\r\n        mounted = 1;\r\n        updateAll(hooks, type);\r\n    }\r\n    function unmount() {\r\n        updateAll(hooks, HOOK_UNMOUNT);\r\n    }\r\n    return hook;\r\n}\n\n/**\r\n * compare 2 array\r\n * @param {array} before\r\n * @param {array} after\r\n * @example\r\n * isEqualArray([1,2,3,4],[1,2,3,4]) // true\r\n * isEqualArray([1,2,3,4],[1,2,3])   // false\r\n * isEqualArray([5,1,2,3],[1,2,3,5]) // false\r\n * isEqualArray([],[]) // true\r\n * @returns {boolean}\r\n */\r\nfunction isEqualArray(before, after) {\r\n    let length = before.length;\r\n    if (length !== after.length) return false;\r\n    for (let i = 0; i < length; i++) {\r\n        if (before[i] !== after[i]) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nconst isFunction = (value) => typeof value == \"function\";\r\n\r\nconst isObject = (value) => typeof value == \"object\";\n\nconst KEY = Symbol(\"\");\r\nconst GLOBAL_ID = Symbol(\"\");\r\nconst FROM_PROP = {\r\n    id: 1,\r\n    className: 1,\r\n    checked: 1,\r\n    value: 1,\r\n    selected: 1,\r\n};\r\nconst WITH_ATTR = {\r\n    list: 1,\r\n    type: 1,\r\n    size: 1,\r\n    form: 1,\r\n    width: 1,\r\n    height: 1,\r\n    src: 1,\r\n};\r\nconst EMPTY_PROPS = {};\r\nconst EMPTY_CHILDREN = [];\r\nconst TYPE_TEXT = 3;\r\nconst TYPE_ELEMENT = 1;\r\nconst $ = document;\r\n\r\nfunction h(type, props, ...children) {\r\n    props = props || EMPTY_PROPS;\r\n\r\n    children = flat(props.children || children);\r\n\r\n    if (!children.length) {\r\n        children = EMPTY_CHILDREN;\r\n    }\r\n\r\n    return {\r\n        type,\r\n        props,\r\n        children,\r\n        key: props.key,\r\n        shadow: props.shadowDom,\r\n        raw: type.nodeType == TYPE_ELEMENT,\r\n    };\r\n}\r\n\r\nfunction render(vnode, node, id = GLOBAL_ID) {\r\n    diff(id, node, vnode);\r\n}\r\n\r\nfunction diff(id, node, vnode, isSvg) {\r\n    let isNewNode;\r\n    // If the node maintains the source vnode it escapes from the update tree\r\n    if (node && node[id] && node[id].vnode == vnode) return node;\r\n    // The process only continues when you may need to create a node\r\n    if (vnode != null || !node) {\r\n        isSvg = isSvg || vnode.type == \"svg\";\r\n        isNewNode =\r\n            vnode.type != \"host\" &&\r\n            (vnode.raw\r\n                ? node != vnode.type\r\n                : node\r\n                ? node.localName != vnode.type\r\n                : !node);\r\n\r\n        if (isNewNode) {\r\n            let nextNode;\r\n            if (vnode.type != null) {\r\n                if (vnode.type.nodeType) {\r\n                    return vnode.type;\r\n                }\r\n                nextNode = isSvg\r\n                    ? $.createElementNS(\r\n                          \"http://www.w3.org/2000/svg\",\r\n                          vnode.type\r\n                      )\r\n                    : $.createElement(\r\n                          vnode.type,\r\n                          vnode.is ? { is: vnode.is } : null\r\n                      );\r\n            } else {\r\n                return $.createTextNode(vnode + \"\");\r\n            }\r\n\r\n            node = nextNode;\r\n        }\r\n    }\r\n    if (node.nodeType == TYPE_TEXT) {\r\n        vnode += \"\";\r\n        if (node.data != vnode) {\r\n            node.data = vnode || \"\";\r\n        }\r\n        return node;\r\n    }\r\n\r\n    let oldVNode = node[id] ? node[id].vnode : EMPTY_PROPS;\r\n    let oldVnodeProps = oldVNode.props || EMPTY_PROPS;\r\n    let oldVnodeChildren = oldVNode.children || EMPTY_CHILDREN;\r\n    let handlers = isNewNode || !node[id] ? {} : node[id].handlers;\r\n\r\n    if (vnode.shadow) {\r\n        if (!node.shadowRoot) {\r\n            node.attachShadow({ mode: \"open\" });\r\n        }\r\n    }\r\n\r\n    if (vnode.props != oldVnodeProps) {\r\n        diffProps(node, oldVnodeProps, vnode.props, handlers, isSvg);\r\n    }\r\n\r\n    if (vnode.children != oldVnodeChildren) {\r\n        let nextParent = vnode.shadow ? node.shadowRoot : node;\r\n        diffChildren(id, nextParent, vnode.children, isSvg);\r\n    }\r\n\r\n    node[id] = { vnode, handlers };\r\n\r\n    return node;\r\n}\r\n\r\nfunction diffChildren(id, parent, children, isSvg) {\r\n    let keyes = children._;\r\n    let childrenLenght = children.length;\r\n    let childNodes = parent.childNodes;\r\n    let childNodesLength = childNodes.length;\r\n    let index = keyes\r\n        ? 0\r\n        : childNodesLength > childrenLenght\r\n        ? childrenLenght\r\n        : childNodesLength;\r\n\r\n    for (; index < childNodesLength; index++) {\r\n        let childNode = childNodes[index];\r\n\r\n        if (keyes) {\r\n            let key = childNode[KEY];\r\n            if (keyes.has(key)) {\r\n                keyes.set(key, childNode);\r\n                continue;\r\n            }\r\n        }\r\n\r\n        index--;\r\n        childNodesLength--;\r\n        childNode.remove();\r\n    }\r\n    for (let i = 0; i < childrenLenght; i++) {\r\n        let child = children[i];\r\n        let indexChildNode = childNodes[i];\r\n        let key = keyes ? child.key : i;\r\n        let childNode = keyes ? keyes.get(key) : indexChildNode;\r\n\r\n        if (keyes && childNode) {\r\n            if (childNode != indexChildNode) {\r\n                parent.insertBefore(childNode, indexChildNode);\r\n            }\r\n        }\r\n\r\n        if (keyes && !child.key) continue;\r\n\r\n        let nextChildNode = diff(id, childNode, child, isSvg);\r\n\r\n        if (!childNode) {\r\n            if (childNodes[i]) {\r\n                parent.insertBefore(nextChildNode, childNodes[i]);\r\n            } else {\r\n                parent.appendChild(nextChildNode);\r\n            }\r\n        } else if (nextChildNode != childNode) {\r\n            parent.replaceChild(nextChildNode, childNode);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {Object} props\r\n * @param {Object} nextProps\r\n * @param {boolean} isSvg\r\n * @param {Object} handlers\r\n **/\r\nfunction diffProps(node, props, nextProps, handlers, isSvg) {\r\n    for (let key in props) {\r\n        if (!(key in nextProps)) {\r\n            setProperty(node, key, props[key], null, isSvg, handlers);\r\n        }\r\n    }\r\n    for (let key in nextProps) {\r\n        setProperty(node, key, props[key], nextProps[key], isSvg, handlers);\r\n    }\r\n}\r\n\r\nfunction setProperty(node, key, prevValue, nextValue, isSvg, handlers) {\r\n    key = key == \"class\" && !isSvg ? \"className\" : key;\r\n    // define empty value\r\n    prevValue = prevValue == null ? null : prevValue;\r\n    nextValue = nextValue == null ? null : nextValue;\r\n\r\n    if (key in node && FROM_PROP[key]) {\r\n        prevValue = node[key];\r\n    }\r\n\r\n    if (nextValue === prevValue || key == \"shadowDom\") return;\r\n\r\n    if (\r\n        key[0] == \"o\" &&\r\n        key[1] == \"n\" &&\r\n        (isFunction(nextValue) || isFunction(prevValue))\r\n    ) {\r\n        setEvent(node, key, nextValue, handlers);\r\n    } else if (key == \"key\") {\r\n        node[KEY] = nextValue;\r\n    } else if (key == \"ref\") {\r\n        if (nextValue) nextValue.current = node;\r\n    } else if (key == \"style\") {\r\n        let style = node.style;\r\n\r\n        prevValue = prevValue || \"\";\r\n        nextValue = nextValue || \"\";\r\n\r\n        let prevIsObject = isObject(prevValue);\r\n        let nextIsObject = isObject(nextValue);\r\n\r\n        if (prevIsObject) {\r\n            for (let key in prevValue) {\r\n                if (nextIsObject) {\r\n                    if (!(key in nextValue)) setPropertyStyle(style, key, null);\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (nextIsObject) {\r\n            for (let key in nextValue) {\r\n                let value = nextValue[key];\r\n                if (prevIsObject && prevValue[key] === value) continue;\r\n                setPropertyStyle(style, key, value);\r\n            }\r\n        } else {\r\n            style.cssText = nextValue;\r\n        }\r\n    } else {\r\n        if (!isSvg && !WITH_ATTR[key] && key in node) {\r\n            node[key] = nextValue == null ? \"\" : nextValue;\r\n        } else if (nextValue == null) {\r\n            node.removeAttribute(key);\r\n        } else {\r\n            node.setAttribute(\r\n                key,\r\n                isObject(nextValue) ? JSON.stringify(nextValue) : nextValue\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param {import(\"./render\").HTMLNode} node\r\n * @param {string} type\r\n * @param {function} [nextHandler]\r\n * @param {object} handlers\r\n */\r\nfunction setEvent(node, type, nextHandler, handlers) {\r\n    // get the name of the event to use\r\n    type = type.slice(type[2] == \"-\" ? 3 : 2);\r\n    // add handleEvent to handlers\r\n    if (!handlers.handleEvent) {\r\n        /**\r\n         * {@link https://developer.mozilla.org/es/docs/Web/API/EventTarget/addEventListener#The_value_of_this_within_the_handler}\r\n         **/\r\n        handlers.handleEvent = (event) =>\r\n            handlers[event.type].call(node, event);\r\n    }\r\n    if (nextHandler) {\r\n        // create the subscriber if it does not exist\r\n        if (!handlers[type]) {\r\n            node.addEventListener(type, handlers);\r\n        }\r\n        // update the associated event\r\n        handlers[type] = nextHandler;\r\n    } else {\r\n        // \tdelete the associated event\r\n        if (handlers[type]) {\r\n            node.removeEventListener(type, handlers);\r\n            delete handlers[type];\r\n        }\r\n    }\r\n}\r\n\r\nfunction setPropertyStyle(style, key, value) {\r\n    let method = \"setProperty\";\r\n    if (value == null) {\r\n        method = \"removeProperty\";\r\n        value = null;\r\n    }\r\n    if (~key.indexOf(\"-\")) {\r\n        style[method](key, value);\r\n    } else {\r\n        style[key] = value;\r\n    }\r\n}\r\n\r\nfunction flat(children, map = []) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        let child = children[i];\r\n        if (child) {\r\n            if (Array.isArray(child)) {\r\n                flat(child, map);\r\n                continue;\r\n            }\r\n            if (child.key != null) {\r\n                if (!map._) map._ = new Map();\r\n\r\n                map._.set(child.key);\r\n            }\r\n        }\r\n        let type = typeof child;\r\n        child =\r\n            child == null || type == \"boolean\" || type == \"function\"\r\n                ? \"\"\r\n                : child;\r\n        map.push(child);\r\n    }\r\n    return map;\r\n}\n\n/**\r\n * Alias for null\r\n */\r\nconst Any = null;\r\n\r\n/**\r\n * This class allows to keep the prop system associated with\r\n * Atomico indifferent to the rest of the core, with the\r\n * intention of its abstraction for other libraries\r\n */\r\nclass BaseElement extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n        this._create();\r\n    }\r\n    /**\r\n     * starts the queue to execute the update method,\r\n     * This method defines the property this.prevent\r\n     * and this.updated\r\n     */\r\n    async _update() {\r\n        if (!this._prevent) {\r\n            this._prevent = true;\r\n            let resolveUpdate;\r\n            this.updated = new Promise((resolve) => (resolveUpdate = resolve));\r\n\r\n            await this.mounted;\r\n\r\n            this._prevent = false;\r\n            this.update();\r\n\r\n            resolveUpdate();\r\n        }\r\n    }\r\n    static get observedAttributes() {\r\n        let { props = {} } = this;\r\n        let init = [];\r\n        let attrs = [];\r\n\r\n        for (let prop in props)\r\n            setProxy(this.prototype, prop, props[prop], attrs, init);\r\n        /**\r\n         * method in charge of starting the class and then calling this.create\r\n         * and after this._update\r\n         */\r\n        this.prototype._create = function () {\r\n            this._attrs = {}; // index associating attribute to a component property\r\n            this._props = {}; // groups the real values of the properties worked by the component\r\n\r\n            init.forEach((fn) => fn(this)); // Allows external access to the component instance\r\n\r\n            this.mounted = new Promise((resolve) => (this.mount = resolve)); // it is solved when connectedCallback is called\r\n            this.unmounted = new Promise((resolve) => (this.unmount = resolve)); // it is solved when disconnectedCallback is called\r\n\r\n            if (this.create) this.create();\r\n\r\n            this._update();\r\n        };\r\n\r\n        return attrs;\r\n    }\r\n    attributeChangedCallback(attr, oldValue, value) {\r\n        if (attr === this._ignoreAttr || oldValue === value) return;\r\n        // Choose the property name to send the update\r\n        this[this._attrs[attr]] = value;\r\n    }\r\n    connectedCallback() {\r\n        this.mount();\r\n    }\r\n    disconnectedCallback() {\r\n        this.unmount();\r\n    }\r\n}\r\n\r\nconst dispatchEvent = (node, type, customEventInit) =>\r\n    node.dispatchEvent(\r\n        new CustomEvent(\r\n            type,\r\n            isObject(customEventInit) ? customEventInit : null\r\n        )\r\n    );\r\n\r\nconst TRUE_VALUES = [true, 1, \"\", \"1\", \"true\"]; // values considered as valid booleans\r\n\r\nconst NOT_CALLABLE = [Function, Any]; // values that are not executable when defining the property\r\n\r\n/**\r\n * Transform a Camel Case string to a Kebab case\r\n * @param {string} prop\r\n * @returns {string}\r\n */\r\nconst getAttr = (prop) => prop.replace(/([A-Z])/g, \"-$1\").toLowerCase();\r\n\r\n/**\r\n * reflects an attribute value of the given element as context\r\n * @param {Element} context\r\n * @param {*} type\r\n * @param {string} attr\r\n * @param {*} value\r\n */\r\nconst reflectValue = (context, type, attr, value) =>\r\n    value == null || (type == Boolean && !value)\r\n        ? context.removeAttribute(attr)\r\n        : context.setAttribute(\r\n              attr,\r\n              isObject(value)\r\n                  ? JSON.stringify(value)\r\n                  : type == Boolean\r\n                  ? \"\"\r\n                  : value\r\n          );\r\n/**\r\n * Constructs the setter and getter of the associated property\r\n * only if it is not defined in the prototype\r\n * @param {*} proto\r\n * @param {string} prop\r\n * @param {*} schema\r\n * @param {string[]} attrs\r\n * @param {Function[]} init\r\n */\r\nfunction setProxy(proto, prop, schema, attrs, init) {\r\n    if (!(prop in proto)) {\r\n        let { type, reflect, event, value, attr = getAttr(prop) } =\r\n            isObject(schema) && schema != Any ? schema : { type: schema };\r\n\r\n        let isCallable = !NOT_CALLABLE.includes(type);\r\n\r\n        attrs.push(attr);\r\n\r\n        function set(newValue) {\r\n            let oldValue = this[prop];\r\n\r\n            let { error, value } = filterValue(\r\n                type,\r\n                isCallable && isFunction(newValue)\r\n                    ? newValue(oldValue)\r\n                    : newValue\r\n            );\r\n\r\n            if (error && value != null) {\r\n                throw `The value defined for prop '${prop}' must be of type '${type.name}'`;\r\n            }\r\n\r\n            if (oldValue == value) return;\r\n\r\n            this._props[prop] = value;\r\n\r\n            this._update();\r\n\r\n            this.updated.then(() => {\r\n                if (event) dispatchEvent(this, event);\r\n\r\n                if (reflect) {\r\n                    this._ignoreAttr = attr;\r\n                    reflectValue(this, type, attr, this[prop]);\r\n                    this._ignoreAttr = null;\r\n                }\r\n            });\r\n        }\r\n\r\n        Object.defineProperty(proto, prop, {\r\n            set,\r\n            get() {\r\n                return this._props[prop];\r\n            },\r\n        });\r\n\r\n        init.push((context) => {\r\n            if (value != null) context[prop] = value;\r\n            context._attrs[attr] = prop;\r\n        });\r\n    }\r\n}\r\n/**\r\n * Filter the values based on their type\r\n * @param {*} type\r\n * @param {*} value\r\n * @returns {{error?:boolean,value:*}}\r\n */\r\nfunction filterValue(type, value) {\r\n    if (type == Any) return { value };\r\n\r\n    try {\r\n        if (type == Boolean) {\r\n            value = TRUE_VALUES.includes(value);\r\n        } else if (typeof value == \"string\") {\r\n            value =\r\n                type == Number\r\n                    ? Number(value)\r\n                    : type == Object || type == Array\r\n                    ? JSON.parse(value)\r\n                    : value;\r\n        }\r\n        if ({}.toString.call(value) == `[object ${type.name}]`) {\r\n            return { value, error: type == Number && Number.isNaN(value) };\r\n        }\r\n    } catch (e) {}\r\n\r\n    return { value, error: true };\r\n}\n\n/**\r\n * Wrap the configuration that unites base-element and Atomico\r\n * @param {Function} component\r\n * @returns {HTMLElement}\r\n */\r\nfunction createCustomElement(component) {\r\n    let Element = class extends BaseElement {\r\n        async create() {\r\n            let id = Symbol();\r\n\r\n            this.update = () => {\r\n                render(hooks.load(component, { ...this._props }), this, id);\r\n                hooks.updated();\r\n            };\r\n\r\n            let hooks = createHooks(() => this._update(), this);\r\n\r\n            await this.unmounted;\r\n\r\n            hooks.unmount();\r\n        }\r\n    };\r\n\r\n    Element.props = component.props;\r\n\r\n    return Element;\r\n}\r\n/**\r\n * Create and register an Atomico component as a Webcomponent\r\n * @param {string|Function} nodeType\r\n * @param {function} [component]\r\n */\r\nconst customElement = (nodeType, component) =>\r\n    isFunction(nodeType)\r\n        ? createCustomElement(nodeType)\r\n        : customElements.define(nodeType, createCustomElement(component));\n\nfunction useHost() {\r\n    return useHook(0, { current: HOOK_CURRENT.ref.host });\r\n}\r\n\r\nfunction useState(initialState) {\r\n    let render = useRender();\r\n    return useHook((state, type) => {\r\n        if (HOOK_MOUNT == type) {\r\n            state[0] = isFunction(initialState) ? initialState() : initialState;\r\n            state[1] = (nextState) => {\r\n                nextState = isFunction(nextState)\r\n                    ? nextState(state[0])\r\n                    : nextState;\r\n                if (nextState != state[0]) {\r\n                    state[0] = nextState;\r\n                    render();\r\n                }\r\n            };\r\n        }\r\n        return state;\r\n    }, []);\r\n}\r\n\r\nfunction useEffect(callback, args) {\r\n    // define whether the effect in the render cycle should be regenerated\r\n    let executeEffect;\r\n    useHook((state, type) => {\r\n        if (executeEffect == null) {\r\n            executeEffect =\r\n                args && state[0] ? !isEqualArray(args, state[0]) : true;\r\n            state[0] = args;\r\n        }\r\n\r\n        switch (type) {\r\n            case HOOK_UPDATE:\r\n            case HOOK_UNMOUNT:\r\n                // save the current args, for comparison\r\n                if ((executeEffect || type == HOOK_UNMOUNT) && state[1]) {\r\n                    // compare the previous snapshot with the generated state\r\n                    state[1]();\r\n                    // clean the effect collector\r\n                    state[1] = 0;\r\n                }\r\n                // delete the previous argument for a hook\r\n                // run if the hook is inserted in a new node\r\n                // Why? ... to perform again dom operations associated with the parent\r\n                if (type == HOOK_UNMOUNT) {\r\n                    state[0] = null;\r\n                }\r\n                break;\r\n            case HOOK_MOUNTED:\r\n            case HOOK_UPDATED:\r\n                // save the current args, for comparison, repeats due to additional type HOOK_MOUNTED\r\n                if (executeEffect || type == HOOK_MOUNTED) {\r\n                    // save the effect collector\r\n                    state[1] = callback();\r\n                }\r\n                // save the comparison argument\r\n                break;\r\n        }\r\n        return state;\r\n    }, []);\r\n}\r\n\r\nfunction useRef(current) {\r\n    return useHook(0, { current });\r\n}\r\n\r\nfunction useMemo(callback, args) {\r\n    let state = useHook(0, []);\r\n\r\n    if (!state[0] || (state[0] && (!args || !isEqualArray(state[0], args)))) {\r\n        state[1] = callback();\r\n    }\r\n    state[0] = args;\r\n    return state[1];\r\n}\r\n\r\nfunction useReducer(reducer, initialState) {\r\n    let render = useRender();\r\n    let hook = useHook((state, type) => {\r\n        if (HOOK_MOUNT == type) {\r\n            state[0] = initialState;\r\n            state[1] = (action) => {\r\n                let nextState = state[2](state[0], action);\r\n                if (nextState != state[0]) {\r\n                    state[0] = nextState;\r\n                    render();\r\n                }\r\n            };\r\n        }\r\n        return state;\r\n    }, []);\r\n    // allows the reduce to always access the scope of the component\r\n    hook[2] = reducer;\r\n\r\n    return hook;\r\n}\r\n/**\r\n * @todo add test use callback\r\n */\r\nfunction useCallback(callback, args) {\r\n    return useMemo(() => callback, args);\r\n}\n\nfunction useProp(name) {\r\n    let ref = useHost();\r\n    if (name in ref.current) {\r\n        if (!ref[name]) {\r\n            ref[name] = [null, nextValue => (ref.current[name] = nextValue)];\r\n        }\r\n        ref[name][0] = ref.current[name];\r\n        return ref[name];\r\n    }\r\n}\n\nfunction useEvent(type, customEventInit) {\r\n    let ref = useHost();\r\n    if (!ref[type]) {\r\n        ref[type] = (detail) =>\r\n            dispatchEvent(\r\n                ref.current,\r\n                type,\r\n                detail ? { ...customEventInit, detail } : customEventInit\r\n            );\r\n    }\r\n    return ref[type];\r\n}\n\nexport { Any, BaseElement, customElement, diffProps, h, render, setEvent, useCallback, useEffect, useEvent, useHost, useMemo, useProp, useReducer, useRef, useState };\n//# sourceMappingURL=core.js.map\n"],"names":[],"mappings":"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"}